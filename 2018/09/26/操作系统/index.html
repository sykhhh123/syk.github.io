<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    操作系统
  
</title>

<meta name="description" content="第一讲中央处理器(CPU)">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://sykhhh123.github.io/2018/09/26/操作系统/index.html">
<meta property="og:site_name" content="未来机械研究所">
<meta property="og:description" content="第一讲中央处理器(CPU)">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://sykhhh123.github.io/操作系统/中断响应示意.png">
<meta property="og:image" content="https://sykhhh123.github.io/操作系统/中断响应示意图.png">
<meta property="og:updated_time" content="2018-11-26T08:59:24.120Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="第一讲中央处理器(CPU)">
<meta name="twitter:image" content="https://sykhhh123.github.io/操作系统/中断响应示意.png">


  <link rel="alternative" href="/atom.xml" title="未来机械研究所" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">未来机械研究所</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">未来机械研究所</a></h1>
    
    <div class="info">
      <div class="content">
        
          <div class="description">间歇性努力的肥宅</div>
        
        
          <div class="author">sykhhh123</div>
        
      </div>
      
        <div class="avatar">
          
            <img src="/images/avatar.jpg">
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞/">漏洞</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">10</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="Chan" target="_blank" rel="noopener">Chan</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/sykhhh123/" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-操作系统" class="article article-type-post">
  
    <h1 class="article-header">
      操作系统
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2018-09-26
</span>

    

    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <h1 id="第一讲">第一讲</h1><h2 id="中央处理器(CPU)">中央处理器(CPU)</h2><a id="more"></a> 
<ul>
<li>处理器由运算器，控制器，一系列的寄存器以及高速缓存构成</li>
<li><p>两类寄存器：</p>
<ul>
<li><font color="0x000000009ff">用户可见寄存器</font></li>
<li><font color="0x000000009ff">控制和状态寄存器</font>：<ul>
<li>程序计数器</li>
<li>指令寄存器</li>
<li>程序状态字</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统的需求——保护</p>
<ul>
<li>从操作系统的特征考虑：<ul>
<li>并发，共享-&gt;实现保护和控制</li>
<li>硬件提供基本运行机制：<ul>
<li>处理器具有特权级别，能在不同的特权级别运行不同指令集合</li>
<li>将 OS 和用户程序隔离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>处理器的状态(模式：mod)</p>
<ul>
<li><font color="0x000000009ff">程序状态字寄存器(PSW)</font> 中专门设置若干位</li>
</ul>
</li>
<li><p>特权指令和非特权指令</p>
<ul>
<li>操作系统需要两种状态： <strong>内核态</strong> 和 <strong>用户态</strong></li>
<li>特权指令：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止中断 停机</li>
<li>非特权指令： 控制转移 算术 访管指令</li>
<li>x86 支持 R0-R3 四个级别特权指令 R0 相当于用户态 R3 相当于内核态</li>
</ul>
</li>
<li><p>CPU状态之间的转换</p>
<ul>
<li>用户态-&gt;内核态： 只能中断/异常/陷入机制</li>
<li>内核态-&gt;用户态： 设置 PSW</li>
<li>特殊指令：访管指令（即陷入指令） 提供给用户程序接口调用操作系统的功能 <br> int, trap, syscall, sysenter/sysexit</li>
</ul>
</li>
</ul>
<h1 id="第二讲">第二讲</h1><h2 id="1-_中断机制">1. 中断机制</h2><ul>
<li>操作系统是由 “中断驱动” 或 “事件驱动” 的</li>
<li>主要作用<ul>
<li>及时处理设备发来的中断请求</li>
<li>可使 OS 可以捕获用户程序提出的服务请求</li>
<li>防止用户程序执行过程中的破坏性活动</li>
<li>等等  </li>
</ul>
</li>
<li>中断与异常引入的原因<ul>
<li>中断的引入： 为了支持 CPU 和设备间的并行操作</li>
<li>异常的引入： 表示 CPU 执行指令时本身出现的问题 （算术溢出， 除 0 等）</li>
</ul>
</li>
<li>中断/异常的概念<ul>
<li>CPU 对系统发生的某个事件的一种反应， <font color="0x000000009ff">结果：改变控制流</font></li>
<li>CPU 暂停当前程序， 保留现场， 执行处理程序， 返回断点继续执行。（实际上现在是返回调度程序， 选择一个程序运行而不是立刻返回）</li>
<li>特点：<ul>
<li>随时发生</li>
<li>自动处理</li>
<li>可恢复  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-事件">2.事件</h2><ul>
<li>中断（外中断）<ul>
<li>I/O 中断</li>
<li>时钟中断</li>
<li>硬件故障</li>
</ul>
</li>
<li>异常（内中断）/例外<ul>
<li>系统调用</li>
<li>页错误</li>
<li>保护性异常</li>
<li>断点指令</li>
</ul>
</li>
</ul>
<h2 id="3-中断/异常机制工作原理">3.中断/异常机制工作原理</h2><ul>
<li>硬件（中断响应）： 补货中断源发出的中断/异常请求， 以一定方式响应， 将控制权交给处理程序</li>
<li>软件（中断处理）： 识别中断/异常类型并完成相应的处理</li>
</ul>
<h2 id="4-中断响应">4.中断响应</h2><ul>
<li>处理器控制部件中设有<font color="0x000000009ff">中断寄存器</font></li>
<li><img src="/操作系统/中断响应示意.png" alt=""><br></li>
<li>&lt;img src=/中断响应示意.png&gt;<br><h2 id="5-中断向量表">5.中断向量表</h2></li>
<li>中断向量： 一个内存单元， 存放中断处理程序入口地址和程序运行所需的处理机状态字</li>
<li>硬件执行流程： 按中断号/异常类型的不同，通过中断向量表转移控制权给中断处理程序</li>
<li>中断响应示意图<ul>
<li><img src="/操作系统/中断响应示意图.png" alt=""> <br></li>
<li>硬件只负责保留 PSW 和 PC 两个重要数据（推入系统栈， 不是用户栈）， 其他保护现场工作由中断处理程序操作   </li>
</ul>
</li>
</ul>
<h2 id="6-中断处理程序">6.中断处理程序</h2><ul>
<li>设计操作系统时， 为每一类中断/异常事件编好处理程序， 设置中断向量表</li>
<li>系统运行时若相应中断， 中断硬件部分将 CPU 控制权转给中断处理程序<ul>
<li>保存相关寄存器</li>
<li>分析中断/异常的具体原因</li>
<li>执行对应处理</li>
<li>恢复现场， 返回被打断的程序</li>
</ul>
</li>
</ul>
<h2 id="IA32_中断实例">IA32 中断实例</h2><h3 id="基本概念——x86">基本概念——x86</h3><ul>
<li>中断：硬件信号引发， 分可屏蔽和不可屏蔽</li>
<li>异常：指令执行引发， 对于某些异常 CPU 会执行异常处理程序之前产生硬件出错码并压入内核态堆栈    </li>
<li>中断控制器 PIC / APIC： 转换硬件中断信号为中断向量， 引发中断</li>
<li>实模式： 中断向量表<ul>
<li>入口地址 = 段 &lt;&lt; 4 + 偏移</li>
<li>不支持 CPU 状态切换</li>
<li>与一般的过程调用相似   </li>
</ul>
</li>
<li>保护模式： 中断描述符表<ul>
<li>采用门描述符（中断描述符）数据结构描述中断向量</li>
<li>任务门 <ul>
<li>中断发生时， 必须把取代当前进程的进程的 TSS 选择符放在任务门（linux 未使用）  </li>
</ul>
</li>
<li>中断门<ul>
<li>给出段选择符， 段偏移量  </li>
<li><font color="0x000000009ff">通过中断门后系统会自动禁止中断</font>  </li>
</ul>
</li>
<li>陷阱门<ul>
<li>与中断门类似， 但不自动关中断  </li>
</ul>
</li>
<li>调用门 （linux 未使用）</li>
</ul>
</li>
<li>具体结构见图  </li>
<li>处理过程<ul>
<li>确定相关向量</li>
<li>通过IDTR寄存器找到IDT表，获得中断描述符(表中的第i项)</li>
<li>从GDTR寄存器获得GDT的地址;结合中断描述符中的段选择符，在GDT表获取对应的段描述符;从该段 描述符中得到中断或异常处理程序所在的段基址</li>
<li>特权级检查</li>
</ul>
</li>
<li>特权级检查（数值越小特权级越高）<ul>
<li>确保 CPL （当前程序运行的权限级别，存放在CS 寄存器中） ≤ 门描述符 DPL<ul>
<li>避免应用程序访问特殊的陷阱们或中断门 </li>
</ul>
</li>
<li>确保 CPL ≤ 段描述符 DPL <ul>
<li>当前特权级不低于中断处理程序的特权级  </li>
</ul>
</li>
</ul>
</li>
<li>检查是否发生特权级改变， 若有， 则进行堆栈切换</li>
<li>硬件压栈</li>
<li>若为中断， 则清 IF 位（屏蔽中断）</li>
<li>通过中断描述符内偏移和段描述符的地址找到中断处理程序</li>
</ul>
<h2 id="操作系统运行机制（系统调用）">操作系统运行机制（系统调用）</h2><h3 id="系统调用_System_call">系统调用 System call</h3><ul>
<li>用户在<strong>编程时</strong>可以调用的操作系统功能</li>
<li>是操作系统提供给编程人员的唯一借口</li>
<li>使 CPU 状态从用户态陷入内核态</li>
<li>系统调用和 C 函数库/ API 接口之间的关系（具体见图）</li>
<li>系统调用对应的代码称为内核函数</li>
</ul>
<h3 id="系统调用机制设计与执行过程">系统调用机制设计与执行过程</h3><ol>
<li>中断/异常机制</li>
<li>选择一条特殊指令：陷入指令（访管指令）：引发异常， 引发用户态到内核态切换 </li>
<li>系统调用号与参数： 每个系统调用都事先给定编号</li>
<li>系统调用表： 存放系统调用服务例程（内核函数）的入口地址<ul>
<li>中断向量表 ≠ 系统调用表</li>
<li>从中断向量表 0x80 （linux） 进入系统调用表， 再查系统调用表</li>
</ul>
</li>
</ol>
<ul>
<li>操作系统完成上述 2-4 工作， 第 3 步需要编译器配合</li>
<li>参数传递过程问题， 常用三种方法（系统调用号也是一个参数）<ol>
<li>由陷入指令自带参数（不推荐，指令长度有限）</li>
<li>通过通用寄存器传递参数 （linux 用的比较多）</li>
<li>在内存中开辟专用堆栈区</li>
</ol>
</li>
</ul>
<h3 id="系统调用举例">系统调用举例</h3><ul>
<li>编译</li>
<li>CPU 执行到陷入指令<ol>
<li>中断/异常机制：硬件保护现场， 查中断向量表， 转到系统调用总入口程序</li>
<li>系统调用总入口程序：保存现场；把参数保存到内核堆栈； 查系统调用表把控制权交给相应系统调用处理例程或内核函数</li>
<li>执行</li>
</ol>
</li>
<li>linux x86 的系统调用<ol>
<li>陷入指令 int 128</li>
<li>门描述符：<ul>
<li>对 IDT 表第128号门初始化</li>
<li>门描述符的 2， 3 个字节： 内核代码段选择符</li>
<li>0，1，6，7字节： 偏移量（system_call（）可执行性代码的第一条指令）</li>
<li>门类型： 陷阱门</li>
<li>DPL：3， 与用户级别相同， 允许用户进程使用该门描述符 </li>
</ul>
</li>
</ol>
</li>
<li>系统执行 int 0x80<ul>
<li>由于特选级改变， 要切换栈； 用户栈 -&gt; 内核栈<br><br>CPU 要从任务状态段 TSS 中装入新的栈指针（SS：ESP）</li>
<li>用户栈信息（SS：ESP）， EFLAGS， 用户态 CS， EIP 压栈</li>
<li>EFLAG 压栈后复位 TF， IF 保持不变</li>
<li>用 128 找到门描述符， 找出段选择符装入 CS</li>
<li>代码段描述符中的基地址 + 陷阱门描述符中的偏移量 → 定位 system_call()的入口地址</li>
</ul>
</li>
</ul>
<h3 id="sysenter/sysexit_系统调用机制">sysenter/sysexit 系统调用机制</h3><ul>
<li>X86 提供了上述两条指令用以减少系统调用的开销</li>
</ul>
<h3 id="系统调用作结">系统调用作结</h3><ul>
<li><p>完成系统调用需要的条件</p>
<ul>
<li>静态：封装内核函数-&gt;库函数， 访管指令与陷入机制；编译器；操作系统（初始化，系统调用编号及参数；系统调用表）</li>
<li>动态： 陷入内核， 总入口程序， 保存县城， 查表分派， 执行返回</li>
</ul>
</li>
<li><p>中断发生后 OS 底层工作步骤</p>
<ol>
<li>硬件压栈</li>
<li>硬件从中断向量装入新的 PC</li>
<li>汇编语言过程保存寄存器</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C语言中断服务程序运行</li>
<li>进程调度程序决定下一个将运行的进程</li>
<li>C语言过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程 </li>
</ol>
</li>
</ul>
<h2 id="机制与策略分离原则">机制与策略分离原则</h2><h3 id="存储系统">存储系统</h3><ul>
<li>进程必须把程序和数据放到内存才能执行</li>
<li>操作系统本身也要放在内存中运行</li>
<li><p>多道程序系统中， 若干个程序和相关数据都要进内存</p>
</li>
<li><p>存储器的层次结构：外存， 内存， 高速缓存， 寄存器</p>
</li>
<li><p>存储访问的局部原理</p>
</li>
<li><p>存储分块</p>
</li>
<li><p>高速缓存</p>
</li>
</ul>
<h3 id="I/O访问技术">I/O访问技术</h3><ul>
<li>I/O 控制使用一下技术<ul>
<li>程序控制方式</li>
<li>中断驱动方式</li>
<li>直接存储器存取（DMA）方式 </li>
</ul>
</li>
</ul>
<h1 id="第三讲">第三讲</h1><h2 id="进程线程模型">进程线程模型</h2><h3 id="多道程序设计">多道程序设计</h3><ul>
<li>并发环境： 一段时间间隔内， 单处理器上有两个或两个以上的程序同时处于开始但未结束的状态，且次序不是事先确定</li>
<li>proceess<ul>
<li>程序的一次执行过程</li>
<li>是正在运行程序的抽象</li>
<li>将一个 CPU 变幻成多个虚拟 CPU</li>
<li>系统资源以进程为单位分配，<strong>每个进程有独立的地址空间</strong></li>
<li>操作系统将 CPU <strong>调度</strong> 给进程</li>
<li>进程是具有独立功能的程序关于某个数据集合上的一次运行活动， 是系统资源分配和调度的独立单位  又称任务（task / job)</li>
<li>进程是对 CPU 的抽象</li>
</ul>
</li>
<li>进程的基本状态<ul>
<li>三种基本状态： 运行态，就绪态， 等待态(block 阻塞）</li>
<li>进程状态之间的转换<ul>
<li>运行可以和就绪互相转换</li>
<li>运行可以转换成等待</li>
<li>等待可以转换成就绪</li>
</ul>
</li>
<li>进程的其他状态<ul>
<li>创建： 已完成创建进程所必要的工作（PID， PCB）但未同意执行该进程（资源有限）</li>
<li>终止： 终止执行后，进程进入该状态， 可完成一些数据统计工作， 资源回收</li>
<li>挂起： 把一个进程从内存转到外村， 进程不占用内存空间， 其他进程映像交换到磁盘上， 用于调节负载 </li>
</ul>
</li>
<li>linux 进程状体（图）</li>
</ul>
</li>
<li>进程控制块 PCB <ul>
<li>PCB<ul>
<li>操作系统表示进程的专门数据结构</li>
<li>记录进程属性， 描述进程动态变化过程</li>
<li>又称 进程描述符/进程属性</li>
</ul>
</li>
<li>操作系统通过 PCB 来控制和管理进程<ul>
<li>PCB是系统感知进程存在的唯一标志</li>
<li>进程与 PCB 一一对应</li>
</ul>
</li>
<li>进程表： 所有进程的 PCB 合集</li>
</ul>
</li>
<li>PCB 内容<ul>
<li>进程描述信息 <ul>
<li>PID</li>
<li>进程名</li>
<li>用户表示符（user id）， 进程组关系</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>当前状态</li>
<li>优先级</li>
<li>代码执行入口地址</li>
<li>程序的磁盘地址</li>
<li>运行统计信息(执行时间， 页面调度)</li>
<li>进程间同步和通信；阻塞原因</li>
<li>进程的队列指针</li>
<li>进程的消息队列指针</li>
</ul>
</li>
<li>所拥有的资源和使用情况<ul>
<li>虚拟地址空间的现状</li>
<li>打开文件列表</li>
</ul>
</li>
<li>CPU 现场信息<ul>
<li>寄存器值 </li>
<li>指向赋予该进程的段/页表的指针 </li>
</ul>
</li>
</ul>
</li>
<li>进程队列<ul>
<li>操作系统为每一类进程建立一个或多个队列</li>
<li>队列元素为 PCB</li>
<li>伴随进程状态的改变， 其 PCB 从一个队列进入另一个队列 </li>
</ul>
</li>
</ul>
<h3 id="进程控制">进程控制</h3><ul>
<li>进程控制操作完成进程个状态之间的切换， 由具有特定功能的原语完成<ul>
<li>例子： 进程创建/撤销/挂起/唤醒    </li>
</ul>
</li>
<li>原语： 完成某个操作， 不可分割（原子操作）</li>
<li>进程何时创建：<ul>
<li>系统初始化</li>
<li>操作系统提供的服务</li>
<li>交互用户登录系统</li>
<li>由现有进程派生出一个新进程 fork</li>
<li>提交一个程序执行  </li>
</ul>
</li>
<li><font color="0x000000009ff">进程的创建</font><ul>
<li>给新进程分配一个唯一标识以及进程控制块</li>
<li>为进程分配地址空间</li>
<li>初始化进程控制块： 设置默认值</li>
<li>设置相应的队列指针： 把新进程加到就绪队列的脸表中</li>
<li>创建或扩充其他数据结构</li>
</ul>
</li>
<li>进程的撤销<ul>
<li>结束子进程或线程</li>
<li>收回资源</li>
<li>撤销 PCB</li>
</ul>
</li>
<li>UNIX 的几个进程控制操作<ul>
<li>fork(): 通过复制调用进程来建立新的进程， 是最基本的进程建立过程<ul>
<li>为子进程分配一个空闲的进程描述符 proc 结构</li>
<li>分配给子进程唯一标识 pid</li>
<li><font color="0x000000009ff">以一次一页的方式复制父进程地址空间</font><ul>
<li>写时复制（存储管理技术） COW  </li>
</ul>
</li>
<li>从父进程处继承共享资源， 如打开文件</li>
<li>子进程状态设为就绪， 插入就绪队列</li>
<li>对子进程返回标识符 0</li>
<li>父进程返回子进程 pid</li>
</ul>
</li>
<li>exec(): 包括一系列系统调用， 它们都是通过用一段新的代码覆盖原来的内存空间， 实现进程执行代码的转换</li>
<li>wait(): 提供初级的进程同步措施</li>
<li>exit(): 终止  </li>
</ul>
</li>
</ul>
<h2 id="线程模型">线程模型</h2><ul>
<li>多线程的应用<ul>
<li>解决前台后台的操作处理问题</li>
<li>解决应用中的异步问题</li>
<li>解决应用执行速度问题</li>
<li>解决程序的模块化设计问题 -&gt; 新型程序设计模型</li>
</ul>
</li>
<li>创建线程的开销小雨创建进程的开销<ul>
<li>创建线程不需要新建地址空间，创建新线程花费时间小</li>
<li>线程之间相互通信不需要调用内核（统一进程内的线程共享内存和文件）</li>
</ul>
</li>
<li>线程的基本概念<ul>
<li>进程的两个基本属性：<ul>
<li>资源的拥有者</li>
<li>调度单位</li>
</ul>
</li>
<li>将原来进程的两个属性分别处理<ul>
<li>线程： 进程中一个运行实体， 是 CPU 的调度单位</li>
</ul>
</li>
</ul>
</li>
<li>线程的属性<ul>
<li>有状态及状态转换 -&gt; 需要提供一些操作</li>
<li>不运行时需要保存的上下文： 程序计数器等寄存器</li>
<li>有自己的栈和栈指针</li>
<li>共享所在进程的地址空间和其他资源</li>
<li>可以创建， 请撤销另一个线程（程序开始是一个单线程）</li>
</ul>
</li>
<li>线程的实现<ul>
<li>用户级线程： 在用户空间实现 （unix）<ul>
<li>kernel 不管理线程， 由 runtime system 管理</li>
<li>在用户空间建立线程库：提供一组管理线程的函数</li>
<li>运行时系统： 完成线程的管理工作</li>
<li>内核管理的是进程， 不知道线程的存在</li>
<li>线程切换不需要内核态特权</li>
<li>优点：<ul>
<li>线程切换快</li>
<li>调度算法是应用程序特定的</li>
<li>用户及线程可运行在任何操作系统</li>
</ul>
</li>
<li>缺点：<ul>
<li>大多数系统调用是阻塞的，因此，由于内核阻塞进程， 故进程中所有线程也呗阻塞<ul>
<li>解决方案：</li>
<li>修改系统调用为非阻塞的</li>
<li>重新实现对应系统调用的 I/O 函数库  </li>
</ul>
</li>
<li>内核只将处理器分配给进程， 统一进程中的两个线程不能同时在两个处理器上     </li>
</ul>
</li>
</ul>
</li>
<li>核心级线程： 在内核中实现 （windows）<ul>
<li>内核管理所有线程管理， 并向应用程序提供API接口</li>
<li>内核维护进程和线程的上下文</li>
<li>线程的切换需要内核支持</li>
<li>以线程为基础进行调度</li>
</ul>
</li>
<li>混合——两者结合方法： 在内核中实现， 支持用户线程 （例子 Solaris）   <ul>
<li>线程创建在用户空间完成 </li>
<li>线程调度等在核心态完成</li>
<li>多个用户级线程多路复用多个内核级线程</li>
<li>Solaris<ul>
<li>进程是资源分配和管理的单元</li>
<li>内核级线程是内核的调度单位</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第四讲">第四讲</h1><h2 id="处理器调度">处理器调度</h2><ul>
<li><p>三个层次</p>
<ul>
<li>长程调度<ul>
<li>创建新进程时-&gt;决定是否进入当前活跃进程集合</li>
</ul>
</li>
<li>中程调度<ul>
<li>进程在内外存之间交换</li>
</ul>
</li>
<li>短程调度<ul>
<li>选择就绪进程或线程进入运行状态， 时间短。</li>
</ul>
</li>
</ul>
</li>
<li><p>短程调度： 按调度算法选择</p>
<ul>
<li>如果没有就绪进程， 系统会安排一个系统空闲进程或 idle 进程</li>
<li>调度程序： 挑选就绪进程的内核函数</li>
<li>系统场景： N 个进程就绪， M 个 CPU， 决策给哪个进程分配哪个CPU</li>
</ul>
</li>
<li><p>三个问题：</p>
<ul>
<li>WHAT： 依据什么原则挑选进程/线程以分配 CPU —— 调度算法 </li>
<li>WHEN： 何时分配 CPU —— 调度时机</li>
<li>HOW： 如何分配 CPU  —— 调度过程（进程的上下文切换）</li>
</ul>
</li>
<li><p>CPU 调度的时机</p>
<ul>
<li>事件发生 -&gt; 当前运行的进程暂停运行 -&gt; 硬件响应机制 -&gt; 进入操作系统处理响应时间 -&gt; 结束处理后：<strong>某些进程的状态会发生变化，也可能又创建了一些新的进程</strong> -&gt; 就绪队列有调整 -&gt; 需要进程调度根据预设的调度算法从就绪队列选一个进程 </li>
<li>进程正常终止 或 由于某种错误而终止</li>
<li>新进程创建 或 一个等待进程变成就绪</li>
<li>一个进程从运行态进入阻塞态</li>
<li>一个进程从运行态变为就绪态</li>
<li>内核处理中断后返回用户态时</li>
</ul>
</li>
<li><p>调度过程——进程切换</p>
<ul>
<li>进程调度程序从就绪队列选择了要运行的进程： 这个进程可以是刚刚被暂停的进程， 也可能是另一个新进程</li>
<li>主要包含两部分工作：<ul>
<li><strong>切换全局页目录</strong>以加载一个新的地址空间</li>
<li><strong>切换内核栈和硬件上下文</strong>， 其中硬件上下文包括内核执行新进程需要的全部信息， 如 CPU 相关寄存器。   </li>
</ul>
</li>
<li>场景 A 下 B 上<ul>
<li>保存 A 的上下文</li>
<li>用新状态和其他相关信息更新进 A 的 PCB</li>
<li>A 移入合适的队列</li>
<li>B 该为运行态</li>
<li>恢复 B 的 PCB 和上下文</li>
</ul>
</li>
<li>上下文切换开销<ul>
<li>直接开销： 内核完成切换所用的 CPU 时间<ul>
<li>保存和恢复寄存器</li>
<li>切换地址空间（相关指令比较昂贵）</li>
</ul>
</li>
<li>间接开销：<ul>
<li>高速缓存， 缓冲区缓存， TLB 失效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理器调度算法的设计</strong></p>
<ul>
<li>什么情况下需要仔细斟酌调度算法<ul>
<li>批处理系统 -&gt; 多道程序设计系统 -&gt; 批处理和分时的混合系统 -&gt; 个人计算机 -&gt; 网络服务器</li>
<li>不同操作系统追求的目标不同</li>
</ul>
</li>
<li>调度算法衡量指标<ul>
<li>吞吐量： 每单位时间完成的进程数目</li>
<li>周转时间： 提出请求到运行完成</li>
<li>响应时间： 提出请求到第一次回应</li>
<li>其他<ul>
<li>CPU 利用率</li>
<li>等待时间： 每个进程在就绪队列中等待的时间</li>
</ul>
</li>
</ul>
</li>
<li>设计时考虑的问题<ul>
<li>进程控制块 PCB 中需要记录哪些与 CPU 调度有关的信息</li>
<li>进程优先级及就绪队列的组织</li>
<li>抢占式调度与非抢占式调度</li>
<li>I/O 密集型与 CPU 密集型</li>
<li>时间片</li>
</ul>
</li>
<li>进程优先级（数）<ul>
<li>静态优先级： 进程创建指定， 不能改变</li>
<li>动态优先级： 可以改变</li>
</ul>
</li>
<li>抢占和非抢占<ul>
<li>可抢占式： 当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的 CPU（通过中断/事件等）， 提供给具有更高优先级的进程使用   </li>
<li>不可抢占： 某一进程被调度后， 除非由于它自身的原因不能允许， 否则一直运行下去</li>
</ul>
</li>
<li>I/O 密集型和 CPU 密集型<ul>
<li>I/O 密集型： 频繁 I/O</li>
<li>CPU 密集型： 需要大量 CPU 时间进行计算</li>
<li>未来对 I/O 密集型进程的调度处理更重要</li>
</ul>
</li>
<li>时间片： 一个时间段， 分配给调度上 CPU 的进程， 确定了允许该进程运行的时间长度<ul>
<li>考虑因素： 进程切换的开销， 对响应时间的要求， 就绪进程个数， CPU 能力， 进程对行<br>为</li>
</ul>
</li>
</ul>
</li>
<li><p>调度算法</p>
<ul>
<li>批处理系统中的调度算法<ul>
<li>先来先服务<ul>
<li>没有抢占</li>
<li>优点： 公平， 简单</li>
<li>缺点： <ul>
<li>长进程之后的端进程需要等待很长时间，不利于用户的交互体验</li>
<li>I/O 资源和 CPU 资源的利用率较低</li>
</ul>
</li>
</ul>
</li>
<li>短作业优先：<ul>
<li>最短作业优先<ul>
<li>可以抢占（最短剩余时间）， 也可以非抢占</li>
<li>思路： 先完成短的作业， 改善短作业的周转时间  </li>
</ul>
</li>
<li>最短剩余时间优先</li>
<li>优点/缺点：<ul>
<li>最短的平均周转时间（在所有进程同时可运行时， 采用 SJF 调度算法可以得到最短的平均周转时间）</li>
<li>不公平： 长任务容易得不到处理时间</li>
<li>需要预测未来</li>
</ul>
</li>
</ul>
</li>
<li>最高响应比优先 HRRN<ul>
<li>一个综合算法</li>
<li>响应比 R = 作业周转时间/作业处理时间 <br>=（作业处理时间+作业等待时间）/ 作业处理时间 <br>= 1 + （作业等待时间/作业处理时间） </li>
</ul>
</li>
</ul>
</li>
<li>交互式系统重的调度算法<ul>
<li>轮转调度 RR<ul>
<li>周期性切换任务， 每个进程分配一个时间片， 时钟中断-&gt;轮换 </li>
<li>目标： 为短任务改善平均响应时间</li>
<li>时间片选择：<ul>
<li>太长——大于典型的交互时间， 降级为先来先服务， 延长短进程响应时间</li>
<li>太短——小于典型的交互时间， 切换开销大？</li>
</ul>
</li>
<li>优缺点：<ul>
<li>公平</li>
<li>有利于交互式计算， 响应时间快</li>
<li>较高切换花销 ， 时间片 10 ms 切换花费 0.1ms， 占比 1%</li>
<li>RR 对不同大小的进程是有利的， 但是对于相同大小的进程反而延长平均周转时间</li>
</ul>
</li>
<li>改进： 虚拟轮转法 Virtual RR<ul>
<li>对计算密集型进程如何分配时间片</li>
<li>对 I/O 的进程放进专门的队列       </li>
</ul>
</li>
</ul>
</li>
<li>优先级调度<ul>
<li>通常系统进程优先级高于用户进程 <br> 前台进程优先级高于后台进程 <br> 操作系统更偏好 I/O 型进程</li>
<li>就绪队列可以按照优先级组织</li>
<li>实现简单； 不公平</li>
<li>优先级发转问题（优先级反置/翻转/倒挂）（抢占）</li>
<li>现象： 一个低优先级进程持有一个高优先级进程所需要的资源， 使得高优先级进程等待低优先级进程运行</li>
<li>影响： 系统错误， 高优先级停滞，系统性能降低</li>
<li>解决方案：<ul>
<li>设置优先级上限（优先级天花板协议）</li>
<li>优先级继承</li>
<li>使用中断禁止</li>
</ul>
</li>
</ul>
</li>
<li>多级队列 与 多级反馈队列<ul>
<li>设置多个就绪队列， 第一级队列优先级最高</li>
<li>给不同就绪队列中的进程分配长度不同的时间片， 第一级时间片最小；随着队列优先级别的降低， 时间片增大</li>
<li>第一级队列为空时， 在第二级队列调度， 以此类推</li>
<li>各队列按照时间片轮转方式进行调度</li>
<li>一个新创建进程就绪后， 进入第一级队列</li>
<li>进程用完时间片儿放弃 CPU， 进入下一级就绪队列</li>
<li>由于阻塞儿放弃 CPU 的进程进入相应的等待队列， 一旦等待的事件发生， 该进程回到原来等级的就绪队列（不一定从队尾进， 可以设计）（再次调度上 CPU 时时间片的处理）（非抢占）</li>
<li>若允许抢占</li>
<li>当有一个优先级更高的进程就绪时， 可以抢占 CPU</li>
<li>被抢占的进程回到原来一级就绪队列的末尾/队首   </li>
</ul>
</li>
<li>其他： <ul>
<li>公平共享调度</li>
<li>保证调度</li>
<li>彩票调度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="windows_线程调度">windows 线程调度</h2><ul>
<li>调度单位： 线程</li>
<li>动态优先级， 抢占调度， 结合时间配额调整<ul>
<li>就绪线程按优先级进入相应队列</li>
<li>系统总是选择优先级最高的就绪进程让其运行</li>
<li>同一优先级的各线程按时间片轮转进行调度</li>
<li>多处理机系统中允许多个线程并行运行</li>
</ul>
</li>
<li>线程调度的条件<ul>
<li>正常调度条件</li>
<li>一个线程的优先级改变了</li>
<li>一个线程改变了它的亲和(Affinity)处理机集合</li>
</ul>
</li>
<li>Windows使用32个线程优先级，分成三类<ul>
<li>16-31 实时优先级：不改变优先级</li>
<li>1-15 可变优先级：优先级可在一定范围升降。 <br> 基本优先级 和 当前优先级</li>
<li>0 系统线程： 零页线程:用于对系统中空闲物理页面清零</li>
</ul>
</li>
<li>所有线程都运行在中断优先级0和1，用户态线程运行在中断优先级0，内核态的异步过程调 用运行在中断优先级1（最低的两个）</li>
<li>线程的时间配额： 时间单位可以自定义<ul>
<li>作用： 改变优先级会导致低优先级的进程几乎得不到 CPU， 但可以给一个进程增加时间配额</li>
</ul>
</li>
<li>调度策略：<ul>
<li>主动切换</li>
<li>抢占<ul>
<li>实时优先级被抢占后： 重新获得一个完整时间配额</li>
<li>可变优先级被抢占后： 剩余时间配额保持不变  </li>
</ul>
</li>
<li>时间配额耗尽<ul>
<li>优先级没有降低：</li>
<li>队列有其他就绪进程， 则排回队尾</li>
<li>没有则获得一个新的时间配额</li>
<li>优先级降低：</li>
<li>选择优先级更高的执行</li>
</ul>
</li>
</ul>
</li>
<li>线程优先级提升<ul>
<li>I/O操作完成</li>
<li>信号量或事件等待结束</li>
<li>前台进程中的线程完成一个等待操作</li>
<li>由于窗口活动而唤醒窗口线程</li>
<li>线程处于就绪态超过了一定的时间还没有运行 —— “饥饿”现象，</li>
<li>针对可变优先级范围内(1至15)的线程优先级</li>
</ul>
</li>
</ul>
<h3 id="LINUX_进程调度">LINUX 进程调度</h3><ul>
<li>实时进程<ul>
<li>对调度延迟的要求最高， 要求立即响应并执行</li>
<li>调度策略： FIFO， RR</li>
</ul>
</li>
<li>普通进程<ul>
<li>交互式进程： 间或处于睡眠态， 对响应速度要求高</li>
<li>批处理进程： 后台执行， 能忍受响应延迟</li>
<li>普通进程调度策略： CFS 完全公平调度算法</li>
</ul>
</li>
</ul>
<h4 id="linux2-4调度算法">linux2.4调度算法</h4><ul>
<li>单就绪队列+时间片+优先级</li>
<li>对 runqueue中所有进程的优先级依次进行比较，选择最高优先级的进程作为下一个被调度的进程</li>
<li>创建时进程赋予它一个时间片。时钟中断时递减当前运行进程的时间片，进程的时间片用完时，它必须等待重新赋予时间片才能有机会运行</li>
<li>只有当所有 RUNNING 进程的时间片都用完之后，才对所有进程重新分配时间片。这种设计保证了每个进程都有机会得到执行</li>
<li>counter(时间片)越大，优先级越高<ul>
<li>时间片指的就是 counter 值，每个进程的可能不一样。而且实时进程的 counter 用完之后会立刻重置 counter 然后放入就绪队列，而非实时进程要等待 runqueue 中为空 时，统一重新计算 counter</li>
<li>普通进程的优先级主要由进程描述符中的 counter 字段决定 (再实时进程要等待runqueue中为空 时，统一重新计算counter要加上 nice 设定的静态优先级)</li>
<li>nice 从最初的 UNIX 沿用而来，表示进程的静态负向优先级，取值范围为 19~-20，以-20优先级最高        </li>
</ul>
</li>
<li>缺点：<ul>
<li>可扩展性不好</li>
<li>高负载系统上的调度性能比较低</li>
<li>交互式进程的优化并不完善</li>
<li>实时进程支持度不够</li>
</ul>
</li>
<li>O(1) 调度器改进<ul>
<li>优先级计算方法</li>
<li>pick next 算法</li>
</ul>
</li>
<li>楼梯调度算法 SD<ul>
<li>抛弃动态优先级， 采取完全公平思路</li>
<li>为每一个优先级维护一个进程列表，并将这些列表组织在 active 数组中，当选取下一个要调度进程时， SD算法也同样从 active 数组中直接读取</li>
<li>用完时间片后下降一级， 降到最低一级后回到初始优先级的下一级队列</li>
<li>能避免饥饿， 交互式进程睡眠时， 同等级进程下楼后， 交互式进程苏醒后仍在高处能快速调度</li>
</ul>
</li>
<li>RSDL 对 SD 的改进<ul>
<li>核心： 完全公平</li>
<li>引入 expired 数组</li>
<li>为每个优先级分配一个 “组时间配额” Tg（耗尽后全部下降）</li>
<li>同一优先级的每个进程都拥有同样的“时间配额” Tp （耗尽后自己下降一级优先级）</li>
<li>Tp 与进程的时间片不同，时间片用完后进程直接进入expired数组，一般有 Tp &lt; time_slice， 回到初始优先级队列</li>
</ul>
</li>
</ul>
<h4 id="CFS（Completely_Fair_Scheduling）">CFS（Completely Fair Scheduling）</h4><ul>
<li>完全公平思想:每个进程获得1/n的时间片时间</li>
<li>每个进程有一个“虚拟运行时间”（vruntime, 已经跑了多久）， 调度器会的选择虚拟运行时间最小的进程允许， 与运行时间成正比， 优先级成反比。</li>
<li>虚拟运行时间组织成一棵红黑树,cached最左进程O(1)，调度O(logn)（/linux/include/linux/sched.h）</li>
<li>调度周期：将所有可调度进程全部调度一遍的时间</li>
<li>分配给某个进程p的运行时间，按权重等比例分配。权重：按nice值算出prio_to_weight (/kernel/sched/core.c)</li>
<li>vruntime = (tp/wp)*NICE_O_LOAD</li>
<li>进程更换CPU时的vruntime策略：/kernel/sched/fair.c migrate_task_rq_fair()</li>
</ul>
<h4 id="BFS">BFS</h4><ul>
<li>virtual deadline = jiffies + (user_priority * rr_interval)</li>
<li>优先级顺序：realtime/sched_iso/sched_normal/sched_idleprio</li>
<li>利用bitmap维护一个进程队列头指针的数据结构，依次遍历bitmap的低位到高位，存放优先级从高到低的进程队列</li>
<li>选择virtual deadline最小的进程</li>
<li>进程wakeup：抢占/插入，sleep：VD不变，用完时间片：重新计算VD</li>
</ul>
<h4 id="实时系统调度算法">实时系统调度算法</h4><ul>
<li>静态调度：RMS<ul>
<li>基于优先级的抢占式调度</li>
<li>给所有任务静态分配优先级</li>
</ul>
</li>
<li>动态调度<ul>
<li>EDF：最早截止时间优先算法<ul>
<li>维护一个ddl队列，每次取队列头调度</li>
</ul>
</li>
<li>LLF：最低松弛度优先算法<ul>
<li>松弛度=ddl-当前时间-任务完成还需要的时间</li>
<li>维护松弛度序列，每次取队列头进行调度</li>
<li>抢占当且仅当松弛度为0，否则会超过ddl</li>
<li>如果松弛度相同，选择最久未调度的进程调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多处理器调度">多处理器调度</h3><ul>
<li>对称多处理器：<ul>
<li>每个处理器运行自己的调度程序</li>
<li>对处理器共享资源进程同步</li>
</ul>
</li>
<li>调度算法设计<ul>
<li>需要决定在哪个 CPU 上执行</li>
<li>需要考虑进程在多个 CPU 之间迁移的开销<ul>
<li>缓存， TLB 失效</li>
<li>尽可能使进程在同一个 CPU 上运行</li>
</ul>
</li>
<li>考虑负载均衡         </li>
</ul>
</li>
</ul>
<h1 id="第五讲">第五讲</h1><h2 id="并发环境">并发环境</h2><ul>
<li>顺序环境：只有一个程序运行， 独占所有资源， 不受外界影响<ul>
<li>封闭性：独占资源， 执行时不受外界影响</li>
<li>结果的确定性</li>
<li>调度顺序不重要 </li>
</ul>
</li>
<li>并发环境<ul>
<li>程序执行结果不可再现性： 结果与相对速度有关， 不确定</li>
<li>在并发环境下执行是间断的</li>
<li>资源共享： 系统中资源被多个进程使用</li>
<li>独立性和制约性</li>
<li>程序和计算不再一一对应  </li>
</ul>
</li>
<li>竞争条件<ul>
<li>读写共享资源最终结果取决于进程运行的精确时序</li>
</ul>
</li>
<li>进程互斥： 由于个进程要求使用共享资源， 而这些资源需要排他性使用， 各进程之间竞争使用这些资源<ul>
<li>临界资源： 系统中某些资源一次只允许一个进程使用， 这样的资源称为 <strong>临界资源</strong> 或 <strong>互斥资源</strong> 或 <strong>共享变量</strong></li>
<li>临界区（互斥区）： 各个进程中对某个临界资源实时操作的程序片段<ul>
<li>没有进程在临界区， 想进入临界区的进程可以进入</li>
<li>不允许两个进程同时处于其临界区</li>
<li>临界区外运行的进程不得阻塞其他进程进入临界区</li>
<li>不得使进程无限期等待进入临界区</li>
</ul>
</li>
</ul>
</li>
<li>进程的同步： 多个进程中发生的事件存在某种时序关系，需要相互合作， 共同完成一项任务</li>
</ul>
<h3 id="进程互斥的解决方案">进程互斥的解决方案</h3><ul>
<li>软件方案：<ul>
<li>Dekker 算法</li>
<li>Peterson 算法</li>
</ul>
</li>
<li>硬件方案：<ul>
<li>“开关中断”指令<ul>
<li>简单高效， 代价高， 限制 CPU 并发能力</li>
<li>不适用于多处理器</li>
<li>适用于操作系统本身， 不适用于用户进程</li>
</ul>
</li>
<li>“测试并加锁”指令</li>
</ul>
</li>
<li>以上解决方案会导致<strong>忙等待</strong><ul>
<li>自旋锁 Spin lock （多处理器使用忙等待：可能其他 CPU 会在忙等待期间开锁， 尽可能避免进程切换带来的开销）</li>
</ul>
</li>
<li>临界区导致的优先级反转</li>
</ul>
<h3 id="生产者/消费者问题">生产者/消费者问题</h3><ul>
<li>又称为有界缓冲区问题</li>
<li>睡眠与唤醒原语， 避免忙等待。</li>
</ul>
<h3 id="典型的同步机制">典型的同步机制</h3><h4 id="信号量和_PV_操作">信号量和 PV 操作</h4><ul>
<li>test&amp;set指令会锁住总线，是一条比较贵的指令</li>
<li>信号量：<ul>
<li>一个特殊变量</li>
<li>用于进程间传递信号的一个整数值（semaphore）</li>
<li>结构体：count/queue</li>
</ul>
</li>
<li>P/V操作：<ul>
<li>P操作：<ul>
<li>s.count–</li>
<li>if s.count &lt; 0：<ul>
<li>进程进入阻塞状态，并将进程插入等待队列s.queue的末尾</li>
<li>reschedule()</li>
</ul>
</li>
</ul>
</li>
<li>V操作：<ul>
<li>s.count++</li>
<li>if s.count &lt;= 0：<ul>
<li>唤醒s.queue中的一个进程，</li>
<li>改变状态为就绪态，并插入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>定义及性质<ul>
<li>P/V操作为原语操作（执行过程中不允许中断）</li>
<li>在信号量上定义了三个操作：初始化（非负数）/P操作/V操作</li>
<li>最初提出二元信号量（互斥原则），之后推广到了一般信号量（0/1，多值）或计数信号量（semaphore&gt;1，解决同步问题）</li>
</ul>
</li>
<li>用P/V操作解决进程间互斥问题<ul>
<li>分析并发进程的关键活动，划定临界区</li>
<li>设置信号量mutex，初值为1</li>
<li>在临界区前实施P(mutex)，临界区后实施V(mutex)</li>
</ul>
</li>
<li>解决生产者消费者问题（同步问题）<ul>
<li>定义三个信号量：(Initialize)<ul>
<li>mutex = 1: 互斥信号量，控制对临界区的访问</li>
<li>empty = N: 空缓冲区个数信号量</li>
<li>full = 0: 满缓冲区个数信号量</li>
</ul>
</li>
<li>producer进程产生item后P(empty)然后P(mutex),首先P一个空缓冲区，接着P一个互斥互斥锁，在insert操作后，V掉mutex再V出一个full，表示生产出了一个可用的满缓冲区。</li>
<li>cosumer进程在获取要消耗的item前需要P掉一个full，再P掉mutex，随后获取remove的item，接着V掉mutex，再V掉一个empty，表示一个item已被消耗。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="管程">管程</h4><ul>
<li>为什么引入管程？信号量机制的不足：程序编写困难/效率低</li>
<li>一个程序设计的语言成分，高级同步操作</li>
<li>定义：<ul>
<li>是一个特殊的模块</li>
<li>由关于共享资源的数据结构及在其上操作的一组过程组成</li>
<li>进程与管程：进程只能通过调用管程中的过程来间接的访问管程中的数据结构</li>
</ul>
</li>
<li>互斥：<ul>
<li>管程是互斥进入的：为了保证管程中数据结构的完整性</li>
<li>管程的互斥性是由编译器负责保证的</li>
</ul>
</li>
<li>同步：<ul>
<li>管程中设置条件变量及等待/唤醒操作以解决同步问题</li>
<li>可以让一个进程或线程等待在条件变量上等待（此时应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒。</li>
</ul>
</li>
<li>允许多个进程同时在管程中<ul>
<li>问题：一个进程进入管程执行等待操作，释放了管程的互斥权。而后面进入管程的进程执行唤醒操作时（例如P唤醒Q），进程中便存在两个同时处于活动状态的进程</li>
<li>解决：<ul>
<li>P等待Q执行(Hoare)</li>
<li>Q等待P继续执行(MESA)</li>
<li>规定唤醒为管程中最后一个可执行的操作(Hansen)</li>
</ul>
</li>
<li>Hoare管程<ul>
<li>条件变量：在管程内部说明和使用的一种特殊类型变量<ul>
<li>可以执行wait和signal操作</li>
<li>wait(c):如果紧急等待队列非空，则唤醒第一个等待者，否则释放管程的互斥权，执行此操作的进程进入c队列尾部</li>
<li>signal(c):如果c队列为空，相当于空操作；如果非空则唤醒第一个c队列中的等待者。 </li>
<li>用管程解决生产者消费者问题<ul>
<li>条件变量：full/empty，count计数</li>
<li>insert过程：<ul>
<li>if count == N: wait(full); </li>
<li>insert(item); count++;</li>
<li>if count == 1: signal(empty);</li>
</ul>
</li>
<li>remove过程：<ul>
<li>if count == 0: wait(empty);</li>
<li>remove = remove_item; count–;</li>
<li>if count == N-1: signal(full);</li>
</ul>
</li>
</ul>
</li>
<li>管程实现的途径：直接构造/间接构造：用某种已经实现的同步机制去构造（例子：信号量P/V操作实现管程，PPT读者写者问题）</li>
</ul>
</li>
</ul>
</li>
<li>Mesa管程<ul>
<li>Hoare管程：signal的缺陷<ul>
<li>两次额外的进程切换</li>
<li>是否会使条件队列中的进程永久挂起？</li>
</ul>
</li>
<li>解决：signal-&gt;notify<ul>
<li>notify(x)：当一个正在管程中的进程执行notify(x)时，会使x等待队列中的队首进程进入就绪状态，在CPU可用时调度上CPU</li>
<li>注意需要用while判断条件，因为不保证在等待过程中没有其他进程进入管程</li>
<li>further改进：broadcast(x)：notify在条件变量x上等待的所有进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PTHREADS：锁（解决互斥问题）/条件变量_（解决同步问题）">PTHREADS：锁（解决互斥问题）/条件变量 （解决同步问题）</h4><ul>
<li>锁（互斥量）<ul>
<li>提供两个过程：上锁和解锁</li>
<li>即mutex：互斥量</li>
<li>注意两个过程函数：<ul>
<li>Pthread_mutex_lock: acquire a lock or block</li>
<li>Pthread_mutex_trylock: acquire a lock or fail</li>
</ul>
</li>
</ul>
</li>
<li>条件变量</li>
<li>Pthread_cond_wait(&amp;condp, &amp;mutex)/Pthread_cond_signal()<ul>
<li>先解锁</li>
<li>然后等待唤醒信号</li>
<li>然后上锁</li>
</ul>
</li>
<li>先lock mutex因为在判断buffer是否非空的时候被打断会出现问题</li>
<li>判断条件用while而不是if，因为在wakeup之后可能会出现条件发生改变的情况</li>
</ul>
<h4 id="第一类读者写者问题">第一类读者写者问题</h4><ul>
<li>增加并发性：不需要所有的读者都P&amp;V</li>
<li>只需要第一个读者P最后一个读者V即可</li>
<li>添加计数器rc <ul>
<li>rc++; </li>
<li>if rc==1: P(w);</li>
<li>{…   rc–; }</li>
<li>if rc==0: V(w);</li>
</ul>
</li>
</ul>
<h4 id="锁的实现">锁的实现</h4><ul>
<li>lock():<ul>
<li>disable interrupts</li>
<li>if(value == FREE):<ul>
<li>value = BUSY</li>
</ul>
</li>
<li>else:<ul>
<li>添加线程等待该锁</li>
<li>切换至下一个可运行线程</li>
</ul>
</li>
<li>enable interrupts</li>
</ul>
</li>
<li>硬件解法：忙等待，一直占用CPU等待锁</li>
<li>用户态解法：主动让出（yield）</li>
</ul>
<h4 id="通信机制">通信机制</h4><ul>
<li>解决信号量及管程的不足/多处理器情况下原语失效的问题</li>
<li>基本通信方式：消息传递/共享内存/管道/套接字/远程过程调用（RPC）</li>
<li><strong>消息传递</strong><ul>
<li>send(dest, message)/recieve(src, message)</li>
<li>消息缓冲区：消息头/消息体组成一个消息结构体</li>
<li>发送者执行send()，陷入内核，将消息复制给消息缓冲区，再将消息结构体指针入队（接收进程的PCB中的消息队列）。接收者执行receive()，将内核中的相应的消息取回。</li>
<li>同样可以用消息传递的方式实现生产者消费者问题：<ul>
<li>生产者recieve(cousumer, &amp;m); m = build_message(); send(cosumer, &amp;m);</li>
<li>消费者先send一些空message给生产者，然后recieve(producer, &amp;m); m = extract_message(); send(producer, &amp;m);</li>
</ul>
</li>
</ul>
</li>
<li><strong>共享内存</strong><ul>
<li>进程的某一片地址空间映射到同一片物理内存</li>
<li>相互通信的进程间需要建立公共内存区域，从而实现信息传递</li>
</ul>
</li>
<li><strong>管道（pipe）</strong><ul>
<li>利用一个缓冲传输介质——内存或文件连接两个相互通信的进程</li>
<li>字符流方式写入写出</li>
<li>管道通信机制必须提供的协调能力：互斥/同步/接收进程是否存在</li>
</ul>
</li>
<li><strong>套接字</strong></li>
</ul>
<h1 id="第五讲-1">第五讲</h1><h2 id="死锁">死锁</h2><ul>
<li>一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到资源，这种现象被称为进程死锁，这组进程被称为死锁进程</li>
<li>为什么会出现死锁？资源数量有限/锁和信号量使用错误</li>
<li>可重用资源：可以被多个进程重复使用</li>
<li>可抢占资源/不可抢占资源</li>
<li>可消耗资源：只可使用一次的可以创建和销毁的资源</li>
<li>活锁与饥饿的区别：活锁加锁，轮询，没有进展也没有阻塞；饥饿：资源分配策略决定</li>
<li>产生死锁的必要条件：<ul>
<li>互斥使用</li>
<li>占有且等待（请求和保持， 部分分配）： 已有部分资源， 还需要新的资源</li>
<li>不可抢占（不可剥夺）：资源申请者不能从占有者手中抢夺</li>
<li>循环等待： P1 等 P2， P2 等 P3， ….. ,Pn 等 P1</li>
</ul>
</li>
</ul>
<h2 id="资源分配图（RAG）">资源分配图（RAG）</h2><ul>
<li>用有向图描述资源系统和进程的状态</li>
<li>资源类：用方框表示，进程实例：用方框中的黑圆点表示，进程用圆圈表示</li>
<li>带方向的箭头表示进程对资源的占有和请求</li>
<li>死锁定理：资源分配中没有环路，则系统中没有死锁。如果图中存在环路那么可能会存在死锁。</li>
<li>如果每个资源类中只有一个资源实例，则环路是死锁存在的充分必要条件。</li>
<li>图的化简：<ul>
<li><ol>
<li>找一个非孤立点进程节点且只有分配边，删去该边和相应的边</li>
</ol>
</li>
<li>2.？？？</li>
<li>重复 1/2</li>
</ul>
</li>
</ul>
<h2 id="死锁解决">死锁解决</h2><h3 id="不考虑此问题_——_鸵鸟算法">不考虑此问题 —— 鸵鸟算法</h3><h3 id="阻止死锁发生">阻止死锁发生</h3><ul>
<li>死锁预防： 静态策略——设计和事的资源分配算法，不让死锁发生<ul>
<li>破坏产生死锁的条件<ul>
<li>破坏 互斥使用 条件<ul>
<li>资源转换技术： 独占变为共享资源</li>
<li>SPOOLing 技术： 设计一个 ”精灵daemon“ 进程/线程负责管理打引进，进程需要打印时，将请求发给该 daemon， 由它完成打印任务</li>
</ul>
</li>
<li>破坏 占有且等待 条件<ul>
<li>方案1: 要求每个进程必须一次性申请它所要求的所有资源， 均可满足时才分配<br><br>问题： 资源利用率低， “饥饿”</li>
<li>方案2: 在允许进程动态申请资源前提下规定， 在拿不到资源进入等待之前， 必须释放已占有的全部资源， 若需要则重新申请</li>
</ul>
</li>
<li>破坏 不可抢占 条件<ul>
<li>实现方案： 虚拟化资源</li>
<li>当一个进程申请的资源被其他进程占用时， 可以通过操作系统抢占这一资源（优先级不同）</li>
<li>局限性： 适用于状态易于保存（CPU， 内存）和恢复的资源 </li>
</ul>
</li>
<li>破坏 循环等待 条件<ul>
<li>实现方案： 资源有序分配法</li>
<li>系统中资源标号， 申请时必须按递增次序进行</li>
<li>实现时的问题： 资源如何编号            </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>死锁避免： 动态策略——以不让死锁发生为目标，跟踪并评估资源分配过程， 根据评估结果决策是否分配<ul>
<li>定义： 在系统运行过程中， 对每一个资源申请进行同台检查，根据检查结果决定是否分配， 若可能死锁则不予分配，否则于一分配</li>
</ul>
</li>
</ul>
<pre><code>-<span class="ruby">     安全状态： 如果存在一个由系统中所有进程构成的安全序列 <span class="constant">P1</span>,...,<span class="constant">Pn</span> 则系统是安全的
</span>-<span class="ruby">    安全序列： 一个进程序列是安全的， 如果对于每一个 <span class="constant">Pi</span>， 它**以后尚需要的资源量**不超过系统当前剩余的资源量与前面进程**当前占有**资源量之和（即在前面进程返还资源后能满足要求）， 系统处于安全状态
</span>-<span class="ruby">     不安全状态： 不存在一个安全序列。
</span>-<span class="ruby">      不安全状态一定导致死锁（但不代表已经死锁）
</span>
-<span class="ruby">      银行家算法： 仿照银行发放贷款时采取的控制方式而设计的一种死锁避免算法
</span>    -<span class="ruby">    系统具有的特征：
</span>        -<span class="ruby">    在固定数量的进程中故乡数量固定的资源
</span>        -<span class="ruby">     每个进程预先制定完成工作所需要的最大资源量
</span>        -<span class="ruby">      进程不能申请比系统中可用资源总数还多的资源
</span>        -<span class="ruby">      进程等待资源的时间是有限的
</span>        -<span class="ruby">      如果系统满足了进程对资源的最大需求， 那么进程应该在有限时间内使用资源然后返还
</span>    -<span class="ruby">    n 进程总数， m 资源类总数
</span>    -<span class="ruby">     available array[<span class="number">1</span>~m] 
</span>        &lt;br&gt; max [n][m]
        &lt;br&gt; allocation [n][m]
        &lt;br&gt; need [n][m]
        &lt;br&gt; request [n][m] (这一次申请)
        &lt;br&gt; 简写时忽略资源维度
        -<span class="ruby">    （<span class="number">1</span>） <span class="keyword">if</span> request[i] ≤ need[i]
</span>            &lt;br&gt; 转（2） &lt;br&gt; else 返回错误
        -<span class="ruby">    （<span class="number">2</span>） <span class="keyword">if</span> request[i] ≤ avaliable &lt;br&gt; 转(<span class="number">3</span>) &lt;br&gt; <span class="keyword">else</span> 等待
</span>        -<span class="ruby">      (<span class="number">3</span>) 进行分配运算 修改各个数据结构
</span>    -<span class="ruby">    检查安全状态
</span>        -<span class="ruby">    work[m] 
</span>        -<span class="ruby">     finish[n] （进程是否结束）
</span>        -<span class="ruby">     (<span class="number">1</span>)work = avaliable &lt;br&gt; finish = <span class="keyword">false</span>
</span>        -<span class="ruby">  (<span class="number">2</span>)寻找满足条件的 i &lt;br&gt; finish[i] == <span class="keyword">false</span> &amp;&amp; need[i] ≤ work &lt;br&gt;不存在转到(<span class="number">4</span>)
</span>        -<span class="ruby">  (<span class="number">3</span>)work += allocation[i] &lt;br&gt; finish[i] = <span class="keyword">true</span> &lt;br&gt; 转(<span class="number">2</span>)
</span>        -<span class="ruby">  (<span class="number">4</span>)若所有的i， finish[i] == <span class="keyword">true</span>, 则处于安全状态</span>
</code></pre><h3 id="让死锁发生_——_死锁检测与解除">让死锁发生 —— 死锁检测与解除</h3><ul>
<li>允许死锁发生， 操作系统不断监视系统进展情况， 判断死锁是否发生</li>
<li>一旦死锁发生则采取专门的措施， 解除死锁并以最小的代价恢复操作系统运行</li>
<li>检测时机：<ul>
<li>当进程由于资源请求不满足而等待时检测死锁（缺点： 系统开销大）</li>
<li>定时监测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
</li>
<li>一个简单的死锁检测算法<ul>
<li>每个进程和资源编号</li>
<li>设置一张资源分配表记录各进程与其占用的资源之间的关系</li>
<li>设置一张进程等待表记录各进程与要申请的资源之间的关系</li>
<li>用两张表判断是否形成回路</li>
</ul>
</li>
<li>死锁解除：<ol>
<li>撤销所有死锁进程（开销大）</li>
<li>进程回退再启动(开销大)</li>
<li>按照某种原则逐一撤销死锁进程，直到…</li>
<li>按照某种原则逐一抢占资源(资源被抢占的进程必须回退到之前的对应状态),直到… </li>
</ol>
</li>
</ul>
<h3 id="哲学家就餐问题">哲学家就餐问题</h3><h4 id="为防止死锁发生可采取的措施">为防止死锁发生可采取的措施</h4><ul>
<li>最多允许四个哲学家同时坐在桌子旁</li>
<li>仅当一个哲学家左右两边的筷子都可用时，才允许他拿筷子</li>
<li>给所有哲学家编号，奇数号必须先拿左， 偶数号必须先拿右</li>
</ul>
<h1 id="第八讲_基本内存管理">第八讲 基本内存管理</h1><h2 id="物理内存管理方案">物理内存管理方案</h2><h3 id="空闲内存管理">空闲内存管理</h3><ul>
<li>数据结构<ul>
<li>位图（等长）： 每个分配单元对应于图中的一个位， 0 空闲， 1 占用（或相反）</li>
<li>空闲区表： 每一项纪录空闲去的起始地址， 长度， 下一个块</li>
<li>空闲表</li>
</ul>
</li>
<li>分配算法<ul>
<li>首次适配</li>
<li>下次适配</li>
<li>最佳适配</li>
<li>最差适配</li>
</ul>
</li>
</ul>
<h3 id="伙伴系统_（Linux_底层内存管理采用）">伙伴系统 （Linux 底层内存管理采用）</h3><ul>
<li>一种经典的内存分配方案， 一种特殊的“分离适配”算法</li>
<li>主要思想： 将内存按2的幂次进行划分， 组成若干空闲块链表， 查找该链表找到能满足进程需求的最佳匹配块</li>
<li>一开始整个一块<br> <br> 大小大于一半-&gt; 全部分配<br> <br> 否则划成一半， 重复过程</li>
<li>不是伙伴的块不进行合并</li>
</ul>
<h2 id="基本内存管理方案（逻辑空间）">基本内存管理方案（逻辑空间）</h2><ul>
<li>单一连续块： 每次只允许一个程序， 独占全部内存， 总被加载到同一个内存地址</li>
<li>固定分区： 划分若干区域</li>
<li>可变分区： 根据进程需求， 从内存空间分割出一个分区分配给该进程<ul>
<li>紧缩技术： 在内存移动程序， 将所有小的空闲区合并为较大的空闲区</li>
<li>正在 I/O 的进程不能移动</li>
</ul>
</li>
<li>页式： 逻辑空间按页（和物理空间大小相同）分配成大小相同的区域， 逻辑相邻的页物理不一定相邻<ul>
<li>物理页面 page fream 又称页框 页帧</li>
<li>虚拟页面 page 又称 页   </li>
</ul>
</li>
<li>段式： 按进程逻辑分若干段， 内存动态化分若干不等长区域<ul>
<li>逻辑地址： 段号+段内地址</li>
<li>段表： 段的起始地址 + 段长度   </li>
</ul>
</li>
<li>段页式<ul>
<li>段中分页， 物理内存管理比较简单（克服段式缺点）</li>
</ul>
</li>
</ul>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/deed.z" target="_blank" title="署名-相同方式共享">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/sa.png">
      
      <span>
        本作品采用知识共享 署名-相同方式共享 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


    

  </footer>
</article>







          <div class="main-footer">
  
    © 2018 未来机械研究所 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
