<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    操作系统
  
</title>

<meta name="description" content="第一讲中央处理器(CPU)">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://sykhhh123.github.io/2018/09/26/操作系统/index.html">
<meta property="og:site_name" content="未来机械研究所">
<meta property="og:description" content="第一讲中央处理器(CPU)">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://sykhhh123.github.io/2018/09/26/操作系统/中断响应示意.png">
<meta property="og:image" content="https://sykhhh123.github.io/2018/09/26/操作系统/中断响应示意图.png">
<meta property="og:updated_time" content="2021-01-14T10:28:46.778Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="第一讲中央处理器(CPU)">
<meta name="twitter:image" content="https://sykhhh123.github.io/2018/09/26/操作系统/中断响应示意.png">


  <link rel="alternative" href="/atom.xml" title="未来机械研究所" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">未来机械研究所</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">未来机械研究所</a></h1>
    
    <div class="info">
      <div class="content">
        
          <div class="description">间歇性努力的肥宅</div>
        
        
          <div class="author">sykhhh123</div>
        
      </div>
      
        <div class="avatar">
          
            <img src="/images/avatar.jpg">
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞/">漏洞</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">10</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="Chan" target="_blank" rel="noopener">Chan</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/sykhhh123/" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-操作系统" class="article article-type-post">
  
    <h1 class="article-header">
      操作系统
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2018-09-26
</span>

    

    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <h1 id="第一讲">第一讲</h1><h2 id="中央处理器(CPU)">中央处理器(CPU)</h2><a id="more"></a> 
<ul>
<li>处理器由运算器，控制器，一系列的寄存器以及高速缓存构成</li>
<li><p>两类寄存器：</p>
<ul>
<li><font color="0x000000009ff">用户可见寄存器</font></li>
<li><font color="0x000000009ff">控制和状态寄存器</font>：<ul>
<li>程序计数器</li>
<li>指令寄存器</li>
<li>程序状态字</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统的需求——保护</p>
<ul>
<li>从操作系统的特征考虑：<ul>
<li>并发，共享-&gt;实现保护和控制</li>
<li>硬件提供基本运行机制：<ul>
<li>处理器具有特权级别，能在不同的特权级别运行不同指令集合</li>
<li>将 OS 和用户程序隔离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>处理器的状态(模式：mod)</p>
<ul>
<li><font color="0x000000009ff">程序状态字寄存器(PSW)</font> 中专门设置若干位</li>
</ul>
</li>
<li><p>特权指令和非特权指令</p>
<ul>
<li>操作系统需要两种状态： <strong>内核态</strong> 和 <strong>用户态</strong></li>
<li>特权指令：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止中断 停机</li>
<li>非特权指令： 控制转移 算术 访管指令</li>
<li>x86 支持 R0-R3 四个级别特权指令 R0 相当于用户态 R3 相当于内核态</li>
</ul>
</li>
<li><p>CPU状态之间的转换</p>
<ul>
<li>用户态-&gt;内核态： 只能中断/异常/陷入机制</li>
<li>内核态-&gt;用户态： 设置 PSW</li>
<li>特殊指令：访管指令（即陷入指令） 提供给用户程序接口调用操作系统的功能 <br> int, trap, syscall, sysenter/sysexit</li>
</ul>
</li>
</ul>
<h1 id="第二讲">第二讲</h1><h2 id="1-_中断机制">1. 中断机制</h2><ul>
<li>操作系统是由 “中断驱动” 或 “事件驱动” 的</li>
<li>主要作用<ul>
<li>及时处理设备发来的中断请求</li>
<li>可使 OS 可以捕获用户程序提出的服务请求</li>
<li>防止用户程序执行过程中的破坏性活动</li>
<li>等等  </li>
</ul>
</li>
<li>中断与异常引入的原因<ul>
<li>中断的引入： 为了支持 CPU 和设备间的并行操作</li>
<li>异常的引入： 表示 CPU 执行指令时本身出现的问题 （算术溢出， 除 0 等）</li>
</ul>
</li>
<li>中断/异常的概念<ul>
<li>CPU 对系统发生的某个事件的一种反应， <font color="0x000000009ff">结果：改变控制流</font></li>
<li>CPU 暂停当前程序， 保留现场， 执行处理程序， 返回断点继续执行。（实际上现在是返回调度程序， 选择一个程序运行而不是立刻返回）</li>
<li>特点：<ul>
<li>随时发生</li>
<li>自动处理</li>
<li>可恢复  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-事件">2.事件</h2><ul>
<li>中断（外中断）<ul>
<li>I/O 中断</li>
<li>时钟中断</li>
<li>硬件故障</li>
</ul>
</li>
<li>异常（内中断）/例外<ul>
<li>系统调用</li>
<li>页错误</li>
<li>保护性异常</li>
<li>断点指令</li>
</ul>
</li>
</ul>
<h2 id="3-中断/异常机制工作原理">3.中断/异常机制工作原理</h2><ul>
<li>硬件（中断响应）： 补货中断源发出的中断/异常请求， 以一定方式响应， 将控制权交给处理程序</li>
<li>软件（中断处理）： 识别中断/异常类型并完成相应的处理</li>
</ul>
<h2 id="4-中断响应">4.中断响应</h2><ul>
<li>处理器控制部件中设有<font color="0x000000009ff">中断寄存器</font></li>
<li><img src="/2018/09/26/操作系统/中断响应示意.png" alt="test"><br></li>
<li><br><h2 id="5-中断向量表">5.中断向量表</h2></li>
<li>中断向量： 一个内存单元， 存放中断处理程序入口地址和程序运行所需的处理机状态字</li>
<li>硬件执行流程： 按中断号/异常类型的不同，通过中断向量表转移控制权给中断处理程序</li>
<li>中断响应示意图<ul>
<li><img src="/2018/09/26/操作系统/中断响应示意图.png" alt> <br></li>
<li>硬件只负责保留 PSW 和 PC 两个重要数据（推入系统栈， 不是用户栈）， 其他保护现场工作由中断处理程序操作   </li>
</ul>
</li>
</ul>
<h2 id="6-中断处理程序">6.中断处理程序</h2><ul>
<li>设计操作系统时， 为每一类中断/异常事件编好处理程序， 设置中断向量表</li>
<li>系统运行时若相应中断， 中断硬件部分将 CPU 控制权转给中断处理程序<ul>
<li>保存相关寄存器</li>
<li>分析中断/异常的具体原因</li>
<li>执行对应处理</li>
<li>恢复现场， 返回被打断的程序</li>
</ul>
</li>
</ul>
<h2 id="IA32_中断实例">IA32 中断实例</h2><h3 id="基本概念——x86">基本概念——x86</h3><ul>
<li>中断：硬件信号引发， 分可屏蔽和不可屏蔽</li>
<li>异常：指令执行引发， 对于某些异常 CPU 会执行异常处理程序之前产生硬件出错码并压入内核态堆栈    </li>
<li>中断控制器 PIC / APIC： 转换硬件中断信号为中断向量， 引发中断</li>
<li>实模式： 中断向量表<ul>
<li>入口地址 = 段 &lt;&lt; 4 + 偏移</li>
<li>不支持 CPU 状态切换</li>
<li>与一般的过程调用相似   </li>
</ul>
</li>
<li>保护模式： 中断描述符表<ul>
<li>采用门描述符（中断描述符）数据结构描述中断向量</li>
<li>任务门 <ul>
<li>中断发生时， 必须把取代当前进程的进程的 TSS 选择符放在任务门（linux 未使用）  </li>
</ul>
</li>
<li>中断门<ul>
<li>给出段选择符， 段偏移量  </li>
<li><font color="0x000000009ff">通过中断门后系统会自动禁止中断</font>  </li>
</ul>
</li>
<li>陷阱门<ul>
<li>与中断门类似， 但不自动关中断  </li>
</ul>
</li>
<li>调用门 （linux 未使用）</li>
</ul>
</li>
<li>具体结构见图  </li>
<li>处理过程<ul>
<li>确定相关向量</li>
<li>通过IDTR寄存器找到IDT表，获得中断描述符(表中的第i项)</li>
<li>从GDTR寄存器获得GDT的地址;结合中断描述符中的段选择符，在GDT表获取对应的段描述符;从该段 描述符中得到中断或异常处理程序所在的段基址</li>
<li>特权级检查</li>
</ul>
</li>
<li>特权级检查（数值越小特权级越高）<ul>
<li>确保 CPL （当前程序运行的权限级别，存放在CS 寄存器中） ≤ 门描述符 DPL<ul>
<li>避免应用程序访问特殊的陷阱们或中断门 </li>
</ul>
</li>
<li>确保 CPL ≤ 段描述符 DPL <ul>
<li>当前特权级不低于中断处理程序的特权级  </li>
</ul>
</li>
</ul>
</li>
<li>检查是否发生特权级改变， 若有， 则进行堆栈切换</li>
<li>硬件压栈</li>
<li>若为中断， 则清 IF 位（屏蔽中断）</li>
<li>通过中断描述符内偏移和段描述符的地址找到中断处理程序</li>
</ul>
<h2 id="操作系统运行机制（系统调用）">操作系统运行机制（系统调用）</h2><h3 id="系统调用_System_call">系统调用 System call</h3><ul>
<li>用户在<strong>编程时</strong>可以调用的操作系统功能</li>
<li>是操作系统提供给编程人员的唯一借口</li>
<li>使 CPU 状态从用户态陷入内核态</li>
<li>系统调用和 C 函数库/ API 接口之间的关系（具体见图）</li>
<li>系统调用对应的代码称为内核函数</li>
</ul>
<h3 id="系统调用机制设计与执行过程">系统调用机制设计与执行过程</h3><ol>
<li>中断/异常机制</li>
<li>选择一条特殊指令：陷入指令（访管指令）：引发异常， 引发用户态到内核态切换 </li>
<li>系统调用号与参数： 每个系统调用都事先给定编号</li>
<li>系统调用表： 存放系统调用服务例程（内核函数）的入口地址<ul>
<li>中断向量表 ≠ 系统调用表</li>
<li>从中断向量表 0x80 （linux） 进入系统调用表， 再查系统调用表</li>
</ul>
</li>
</ol>
<ul>
<li>操作系统完成上述 2-4 工作， 第 3 步需要编译器配合</li>
<li>参数传递过程问题， 常用三种方法（系统调用号也是一个参数）<ol>
<li>由陷入指令自带参数（不推荐，指令长度有限）</li>
<li>通过通用寄存器传递参数 （linux 用的比较多）</li>
<li>在内存中开辟专用堆栈区</li>
</ol>
</li>
</ul>
<h3 id="系统调用举例">系统调用举例</h3><ul>
<li>编译</li>
<li>CPU 执行到陷入指令<ol>
<li>中断/异常机制：硬件保护现场， 查中断向量表， 转到系统调用总入口程序</li>
<li>系统调用总入口程序：保存现场；把参数保存到内核堆栈； 查系统调用表把控制权交给相应系统调用处理例程或内核函数</li>
<li>执行</li>
</ol>
</li>
<li>linux x86 的系统调用<ol>
<li>陷入指令 int 128</li>
<li>门描述符：<ul>
<li>对 IDT 表第128号门初始化</li>
<li>门描述符的 2， 3 个字节： 内核代码段选择符</li>
<li>0，1，6，7字节： 偏移量（system_call（）可执行性代码的第一条指令）</li>
<li>门类型： 陷阱门</li>
<li>DPL：3， 与用户级别相同， 允许用户进程使用该门描述符 </li>
</ul>
</li>
</ol>
</li>
<li>系统执行 int 0x80<ul>
<li>由于特选级改变， 要切换栈； 用户栈 -&gt; 内核栈<br><br>CPU 要从任务状态段 TSS 中装入新的栈指针（SS：ESP）</li>
<li>用户栈信息（SS：ESP）， EFLAGS， 用户态 CS， EIP 压栈</li>
<li>EFLAG 压栈后复位 TF， IF 保持不变</li>
<li>用 128 找到门描述符， 找出段选择符装入 CS</li>
<li>代码段描述符中的基地址 + 陷阱门描述符中的偏移量 → 定位 system_call()的入口地址</li>
</ul>
</li>
</ul>
<h3 id="sysenter/sysexit_系统调用机制">sysenter/sysexit 系统调用机制</h3><ul>
<li>X86 提供了上述两条指令用以减少系统调用的开销</li>
</ul>
<h3 id="系统调用作结">系统调用作结</h3><ul>
<li><p>完成系统调用需要的条件</p>
<ul>
<li>静态：封装内核函数-&gt;库函数， 访管指令与陷入机制；编译器；操作系统（初始化，系统调用编号及参数；系统调用表）</li>
<li>动态： 陷入内核， 总入口程序， 保存县城， 查表分派， 执行返回</li>
</ul>
</li>
<li><p>中断发生后 OS 底层工作步骤</p>
<ol>
<li>硬件压栈</li>
<li>硬件从中断向量装入新的 PC</li>
<li>汇编语言过程保存寄存器</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C语言中断服务程序运行</li>
<li>进程调度程序决定下一个将运行的进程</li>
<li>C语言过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程 </li>
</ol>
</li>
</ul>
<h2 id="机制与策略分离原则">机制与策略分离原则</h2><h3 id="存储系统">存储系统</h3><ul>
<li>进程必须把程序和数据放到内存才能执行</li>
<li>操作系统本身也要放在内存中运行</li>
<li><p>多道程序系统中， 若干个程序和相关数据都要进内存</p>
</li>
<li><p>存储器的层次结构：外存， 内存， 高速缓存， 寄存器</p>
</li>
<li><p>存储访问的局部原理</p>
</li>
<li><p>存储分块</p>
</li>
<li><p>高速缓存</p>
</li>
</ul>
<h3 id="I/O访问技术">I/O访问技术</h3><ul>
<li>I/O 控制使用一下技术<ul>
<li>程序控制方式</li>
<li>中断驱动方式</li>
<li>直接存储器存取（DMA）方式 </li>
</ul>
</li>
</ul>
<h1 id="第三讲">第三讲</h1><h2 id="进程线程模型">进程线程模型</h2><h3 id="多道程序设计">多道程序设计</h3><ul>
<li>并发环境： 一段时间间隔内， 单处理器上有两个或两个以上的程序同时处于开始但未结束的状态，且次序不是事先确定</li>
<li>proceess<ul>
<li>程序的一次执行过程</li>
<li>是正在运行程序的抽象</li>
<li>将一个 CPU 变幻成多个虚拟 CPU</li>
<li>系统资源以进程为单位分配，<strong>每个进程有独立的地址空间</strong></li>
<li>操作系统将 CPU <strong>调度</strong> 给进程</li>
<li>进程是具有独立功能的程序关于某个数据集合上的一次运行活动， 是系统资源分配和调度的独立单位  又称任务（task / job)</li>
<li>进程是对 CPU 的抽象</li>
</ul>
</li>
<li>进程的基本状态<ul>
<li>三种基本状态： 运行态，就绪态， 等待态(block 阻塞）</li>
<li>进程状态之间的转换<ul>
<li>运行可以和就绪互相转换</li>
<li>运行可以转换成等待</li>
<li>等待可以转换成就绪</li>
</ul>
</li>
<li>进程的其他状态<ul>
<li>创建： 已完成创建进程所必要的工作（PID， PCB）但未同意执行该进程（资源有限）</li>
<li>终止： 终止执行后，进程进入该状态， 可完成一些数据统计工作， 资源回收</li>
<li>挂起： 把一个进程从内存转到外村， 进程不占用内存空间， 其他进程映像交换到磁盘上， 用于调节负载 </li>
</ul>
</li>
<li>linux 进程状体（图）</li>
</ul>
</li>
<li>进程控制块 PCB <ul>
<li>PCB<ul>
<li>操作系统表示进程的专门数据结构</li>
<li>记录进程属性， 描述进程动态变化过程</li>
<li>又称 进程描述符/进程属性</li>
</ul>
</li>
<li>操作系统通过 PCB 来控制和管理进程<ul>
<li>PCB是系统感知进程存在的唯一标志</li>
<li>进程与 PCB 一一对应</li>
</ul>
</li>
<li>进程表： 所有进程的 PCB 合集</li>
</ul>
</li>
<li>PCB 内容<ul>
<li>进程描述信息 <ul>
<li>PID</li>
<li>进程名</li>
<li>用户表示符（user id）， 进程组关系</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>当前状态</li>
<li>优先级</li>
<li>代码执行入口地址</li>
<li>程序的磁盘地址</li>
<li>运行统计信息(执行时间， 页面调度)</li>
<li>进程间同步和通信；阻塞原因</li>
<li>进程的队列指针</li>
<li>进程的消息队列指针</li>
</ul>
</li>
<li>所拥有的资源和使用情况<ul>
<li>虚拟地址空间的现状</li>
<li>打开文件列表</li>
</ul>
</li>
<li>CPU 现场信息<ul>
<li>寄存器值 </li>
<li>指向赋予该进程的段/页表的指针 </li>
</ul>
</li>
</ul>
</li>
<li>进程队列<ul>
<li>操作系统为每一类进程建立一个或多个队列</li>
<li>队列元素为 PCB</li>
<li>伴随进程状态的改变， 其 PCB 从一个队列进入另一个队列 </li>
</ul>
</li>
</ul>
<h3 id="进程控制">进程控制</h3><ul>
<li>进程控制操作完成进程个状态之间的切换， 由具有特定功能的原语完成<ul>
<li>例子： 进程创建/撤销/挂起/唤醒    </li>
</ul>
</li>
<li>原语： 完成某个操作， 不可分割（原子操作）</li>
<li>进程何时创建：<ul>
<li>系统初始化</li>
<li>操作系统提供的服务</li>
<li>交互用户登录系统</li>
<li>由现有进程派生出一个新进程 fork</li>
<li>提交一个程序执行  </li>
</ul>
</li>
<li><font color="0x000000009ff">进程的创建</font><ul>
<li>给新进程分配一个唯一标识以及进程控制块</li>
<li>为进程分配地址空间</li>
<li>初始化进程控制块： 设置默认值</li>
<li>设置相应的队列指针： 把新进程加到就绪队列的脸表中</li>
<li>创建或扩充其他数据结构</li>
</ul>
</li>
<li>进程的撤销<ul>
<li>结束子进程或线程</li>
<li>收回资源</li>
<li>撤销 PCB</li>
</ul>
</li>
<li>UNIX 的几个进程控制操作<ul>
<li>fork(): 通过复制调用进程来建立新的进程， 是最基本的进程建立过程<ul>
<li>为子进程分配一个空闲的进程描述符 proc 结构</li>
<li>分配给子进程唯一标识 pid</li>
<li><font color="0x000000009ff">以一次一页的方式复制父进程地址空间</font><ul>
<li>写时复制（存储管理技术） COW  </li>
</ul>
</li>
<li>从父进程处继承共享资源， 如打开文件</li>
<li>子进程状态设为就绪， 插入就绪队列</li>
<li>对子进程返回标识符 0</li>
<li>父进程返回子进程 pid</li>
</ul>
</li>
<li>exec(): 包括一系列系统调用， 它们都是通过用一段新的代码覆盖原来的内存空间， 实现进程执行代码的转换</li>
<li>wait(): 提供初级的进程同步措施</li>
<li>exit(): 终止  </li>
</ul>
</li>
</ul>
<h2 id="线程模型">线程模型</h2><ul>
<li>多线程的应用<ul>
<li>解决前台后台的操作处理问题</li>
<li>解决应用中的异步问题</li>
<li>解决应用执行速度问题</li>
<li>解决程序的模块化设计问题 -&gt; 新型程序设计模型</li>
</ul>
</li>
<li>创建线程的开销小雨创建进程的开销<ul>
<li>创建线程不需要新建地址空间，创建新线程花费时间小</li>
<li>线程之间相互通信不需要调用内核（统一进程内的线程共享内存和文件）</li>
</ul>
</li>
<li>线程的基本概念<ul>
<li>进程的两个基本属性：<ul>
<li>资源的拥有者</li>
<li>调度单位</li>
</ul>
</li>
<li>将原来进程的两个属性分别处理<ul>
<li>线程： 进程中一个运行实体， 是 CPU 的调度单位</li>
</ul>
</li>
</ul>
</li>
<li>线程的属性<ul>
<li>有状态及状态转换 -&gt; 需要提供一些操作</li>
<li>不运行时需要保存的上下文： 程序计数器等寄存器</li>
<li>有自己的栈和栈指针</li>
<li>共享所在进程的地址空间和其他资源</li>
<li>可以创建， 请撤销另一个线程（程序开始是一个单线程）</li>
</ul>
</li>
<li>线程的实现<ul>
<li>用户级线程： 在用户空间实现 （unix）<ul>
<li>kernel 不管理线程， 由 runtime system 管理</li>
<li>在用户空间建立线程库：提供一组管理线程的函数</li>
<li>运行时系统： 完成线程的管理工作</li>
<li>内核管理的是进程， 不知道线程的存在</li>
<li>线程切换不需要内核态特权</li>
<li>优点：<ul>
<li>线程切换快</li>
<li>调度算法是应用程序特定的</li>
<li>用户及线程可运行在任何操作系统</li>
</ul>
</li>
<li>缺点：<ul>
<li>大多数系统调用是阻塞的，因此，由于内核阻塞进程， 故进程中所有线程也呗阻塞<ul>
<li>解决方案：</li>
<li>修改系统调用为非阻塞的</li>
<li>重新实现对应系统调用的 I/O 函数库  </li>
</ul>
</li>
<li>内核只将处理器分配给进程， 统一进程中的两个线程不能同时在两个处理器上     </li>
</ul>
</li>
</ul>
</li>
<li>核心级线程： 在内核中实现 （windows）<ul>
<li>内核管理所有线程管理， 并向应用程序提供API接口</li>
<li>内核维护进程和线程的上下文</li>
<li>线程的切换需要内核支持</li>
<li>以线程为基础进行调度</li>
</ul>
</li>
<li>混合——两者结合方法： 在内核中实现， 支持用户线程 （例子 Solaris）   <ul>
<li>线程创建在用户空间完成 </li>
<li>线程调度等在核心态完成</li>
<li>多个用户级线程多路复用多个内核级线程</li>
<li>Solaris<ul>
<li>进程是资源分配和管理的单元</li>
<li>内核级线程是内核的调度单位</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第四讲">第四讲</h1><h2 id="处理器调度">处理器调度</h2><ul>
<li><p>三个层次</p>
<ul>
<li>长程调度<ul>
<li>创建新进程时-&gt;决定是否进入当前活跃进程集合</li>
</ul>
</li>
<li>中程调度<ul>
<li>进程在内外存之间交换</li>
</ul>
</li>
<li>短程调度<ul>
<li>选择就绪进程或线程进入运行状态， 时间短。</li>
</ul>
</li>
</ul>
</li>
<li><p>短程调度： 按调度算法选择</p>
<ul>
<li>如果没有就绪进程， 系统会安排一个系统空闲进程或 idle 进程</li>
<li>调度程序： 挑选就绪进程的内核函数</li>
<li>系统场景： N 个进程就绪， M 个 CPU， 决策给哪个进程分配哪个CPU</li>
</ul>
</li>
<li><p>三个问题：</p>
<ul>
<li>WHAT： 依据什么原则挑选进程/线程以分配 CPU —— 调度算法 </li>
<li>WHEN： 何时分配 CPU —— 调度时机</li>
<li>HOW： 如何分配 CPU  —— 调度过程（进程的上下文切换）</li>
</ul>
</li>
<li><p>CPU 调度的时机</p>
<ul>
<li>事件发生 -&gt; 当前运行的进程暂停运行 -&gt; 硬件响应机制 -&gt; 进入操作系统处理响应时间 -&gt; 结束处理后：<strong>某些进程的状态会发生变化，也可能又创建了一些新的进程</strong> -&gt; 就绪队列有调整 -&gt; 需要进程调度根据预设的调度算法从就绪队列选一个进程 </li>
<li>进程正常终止 或 由于某种错误而终止</li>
<li>新进程创建 或 一个等待进程变成就绪</li>
<li>一个进程从运行态进入阻塞态</li>
<li>一个进程从运行态变为就绪态</li>
<li>内核处理中断后返回用户态时</li>
</ul>
</li>
<li><p>调度过程——进程切换</p>
<ul>
<li>进程调度程序从就绪队列选择了要运行的进程： 这个进程可以是刚刚被暂停的进程， 也可能是另一个新进程</li>
<li>主要包含两部分工作：<ul>
<li><strong>切换全局页目录</strong>以加载一个新的地址空间</li>
<li><strong>切换内核栈和硬件上下文</strong>， 其中硬件上下文包括内核执行新进程需要的全部信息， 如 CPU 相关寄存器。   </li>
</ul>
</li>
<li>场景 A 下 B 上<ul>
<li>保存 A 的上下文</li>
<li>用新状态和其他相关信息更新进 A 的 PCB</li>
<li>A 移入合适的队列</li>
<li>B 该为运行态</li>
<li>恢复 B 的 PCB 和上下文</li>
</ul>
</li>
<li>上下文切换开销<ul>
<li>直接开销： 内核完成切换所用的 CPU 时间<ul>
<li>保存和恢复寄存器</li>
<li>切换地址空间（相关指令比较昂贵）</li>
</ul>
</li>
<li>间接开销：<ul>
<li>高速缓存， 缓冲区缓存， TLB 失效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理器调度算法的设计</strong></p>
<ul>
<li>什么情况下需要仔细斟酌调度算法<ul>
<li>批处理系统 -&gt; 多道程序设计系统 -&gt; 批处理和分时的混合系统 -&gt; 个人计算机 -&gt; 网络服务器</li>
<li>不同操作系统追求的目标不同</li>
</ul>
</li>
<li>调度算法衡量指标<ul>
<li>吞吐量： 每单位时间完成的进程数目</li>
<li>周转时间： 提出请求到运行完成</li>
<li>响应时间： 提出请求到第一次回应</li>
<li>其他<ul>
<li>CPU 利用率</li>
<li>等待时间： 每个进程在就绪队列中等待的时间</li>
</ul>
</li>
</ul>
</li>
<li>设计时考虑的问题<ul>
<li>进程控制块 PCB 中需要记录哪些与 CPU 调度有关的信息</li>
<li>进程优先级及就绪队列的组织</li>
<li>抢占式调度与非抢占式调度</li>
<li>I/O 密集型与 CPU 密集型</li>
<li>时间片</li>
</ul>
</li>
<li>进程优先级（数）<ul>
<li>静态优先级： 进程创建指定， 不能改变</li>
<li>动态优先级： 可以改变</li>
</ul>
</li>
<li>抢占和非抢占<ul>
<li>可抢占式： 当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的 CPU（通过中断/事件等）， 提供给具有更高优先级的进程使用   </li>
<li>不可抢占： 某一进程被调度后， 除非由于它自身的原因不能允许， 否则一直运行下去</li>
</ul>
</li>
<li>I/O 密集型和 CPU 密集型<ul>
<li>I/O 密集型： 频繁 I/O</li>
<li>CPU 密集型： 需要大量 CPU 时间进行计算</li>
<li>未来对 I/O 密集型进程的调度处理更重要</li>
</ul>
</li>
<li>时间片： 一个时间段， 分配给调度上 CPU 的进程， 确定了允许该进程运行的时间长度<ul>
<li>考虑因素： 进程切换的开销， 对响应时间的要求， 就绪进程个数， CPU 能力， 进程对行<br>为</li>
</ul>
</li>
</ul>
</li>
<li><p>调度算法</p>
<ul>
<li>批处理系统中的调度算法<ul>
<li>先来先服务<ul>
<li>没有抢占</li>
<li>优点： 公平， 简单</li>
<li>缺点： <ul>
<li>长进程之后的端进程需要等待很长时间，不利于用户的交互体验</li>
<li>I/O 资源和 CPU 资源的利用率较低</li>
</ul>
</li>
</ul>
</li>
<li>短作业优先：<ul>
<li>最短作业优先<ul>
<li>可以抢占（最短剩余时间）， 也可以非抢占</li>
<li>思路： 先完成短的作业， 改善短作业的周转时间  </li>
</ul>
</li>
<li>最短剩余时间优先</li>
<li>优点/缺点：<ul>
<li>最短的平均周转时间（在所有进程同时可运行时， 采用 SJF 调度算法可以得到最短的平均周转时间）</li>
<li>不公平： 长任务容易得不到处理时间</li>
<li>需要预测未来</li>
</ul>
</li>
</ul>
</li>
<li>最高响应比优先 HRRN<ul>
<li>一个综合算法</li>
<li>响应比 R = 作业周转时间/作业处理时间 <br>=（作业处理时间+作业等待时间）/ 作业处理时间 <br>= 1 + （作业等待时间/作业处理时间） </li>
</ul>
</li>
</ul>
</li>
<li>交互式系统重的调度算法<ul>
<li>轮转调度 RR<ul>
<li>周期性切换任务， 每个进程分配一个时间片， 时钟中断-&gt;轮换 </li>
<li>目标： 为短任务改善平均响应时间</li>
<li>时间片选择：<ul>
<li>太长——大于典型的交互时间， 降级为先来先服务， 延长短进程响应时间</li>
<li>太短——小于典型的交互时间， 切换开销大？</li>
</ul>
</li>
<li>优缺点：<ul>
<li>公平</li>
<li>有利于交互式计算， 响应时间快</li>
<li>较高切换花销 ， 时间片 10 ms 切换花费 0.1ms， 占比 1%</li>
<li>RR 对不同大小的进程是有利的， 但是对于相同大小的进程反而延长平均周转时间</li>
</ul>
</li>
<li>改进： 虚拟轮转法 Virtual RR<ul>
<li>对计算密集型进程如何分配时间片</li>
<li>对 I/O 的进程放进专门的队列       </li>
</ul>
</li>
</ul>
</li>
<li>优先级调度<ul>
<li>通常系统进程优先级高于用户进程 <br> 前台进程优先级高于后台进程 <br> 操作系统更偏好 I/O 型进程</li>
<li>就绪队列可以按照优先级组织</li>
<li>实现简单； 不公平</li>
<li>优先级发转问题（优先级反置/翻转/倒挂）（抢占）</li>
<li>现象： 一个低优先级进程持有一个高优先级进程所需要的资源， 使得高优先级进程等待低优先级进程运行</li>
<li>影响： 系统错误， 高优先级停滞，系统性能降低</li>
<li>解决方案：<ul>
<li>设置优先级上限（优先级天花板协议）</li>
<li>优先级继承</li>
<li>使用中断禁止</li>
</ul>
</li>
</ul>
</li>
<li>多级队列 与 多级反馈队列<ul>
<li>设置多个就绪队列， 第一级队列优先级最高</li>
<li>给不同就绪队列中的进程分配长度不同的时间片， 第一级时间片最小；随着队列优先级别的降低， 时间片增大</li>
<li>第一级队列为空时， 在第二级队列调度， 以此类推</li>
<li>各队列按照时间片轮转方式进行调度</li>
<li>一个新创建进程就绪后， 进入第一级队列</li>
<li>进程用完时间片儿放弃 CPU， 进入下一级就绪队列</li>
<li>由于阻塞儿放弃 CPU 的进程进入相应的等待队列， 一旦等待的事件发生， 该进程回到原来等级的就绪队列（不一定从队尾进， 可以设计）（再次调度上 CPU 时时间片的处理）（非抢占）</li>
<li>若允许抢占</li>
<li>当有一个优先级更高的进程就绪时， 可以抢占 CPU</li>
<li>被抢占的进程回到原来一级就绪队列的末尾/队首   </li>
</ul>
</li>
<li>其他： <ul>
<li>公平共享调度</li>
<li>保证调度</li>
<li>彩票调度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="windows_线程调度">windows 线程调度</h2><ul>
<li>调度单位： 线程</li>
<li>动态优先级， 抢占调度， 结合时间配额调整<ul>
<li>就绪线程按优先级进入相应队列</li>
<li>系统总是选择优先级最高的就绪进程让其运行</li>
<li>同一优先级的各线程按时间片轮转进行调度</li>
<li>多处理机系统中允许多个线程并行运行</li>
</ul>
</li>
<li>线程调度的条件<ul>
<li>正常调度条件</li>
<li>一个线程的优先级改变了</li>
<li>一个线程改变了它的亲和(Affinity)处理机集合</li>
</ul>
</li>
<li>Windows使用32个线程优先级，分成三类<ul>
<li>16-31 实时优先级：不改变优先级</li>
<li>1-15 可变优先级：优先级可在一定范围升降。 <br> 基本优先级 和 当前优先级</li>
<li>0 系统线程： 零页线程:用于对系统中空闲物理页面清零</li>
</ul>
</li>
<li>所有线程都运行在中断优先级0和1，用户态线程运行在中断优先级0，内核态的异步过程调 用运行在中断优先级1（最低的两个）</li>
<li>线程的时间配额： 时间单位可以自定义<ul>
<li>作用： 改变优先级会导致低优先级的进程几乎得不到 CPU， 但可以给一个进程增加时间配额</li>
</ul>
</li>
<li>调度策略：<ul>
<li>主动切换</li>
<li>抢占<ul>
<li>实时优先级被抢占后： 重新获得一个完整时间配额</li>
<li>可变优先级被抢占后： 剩余时间配额保持不变  </li>
</ul>
</li>
<li>时间配额耗尽<ul>
<li>优先级没有降低：</li>
<li>队列有其他就绪进程， 则排回队尾</li>
<li>没有则获得一个新的时间配额</li>
<li>优先级降低：</li>
<li>选择优先级更高的执行</li>
</ul>
</li>
</ul>
</li>
<li>线程优先级提升<ul>
<li>I/O操作完成</li>
<li>信号量或事件等待结束</li>
<li>前台进程中的线程完成一个等待操作</li>
<li>由于窗口活动而唤醒窗口线程</li>
<li>线程处于就绪态超过了一定的时间还没有运行 —— “饥饿”现象，</li>
<li>针对可变优先级范围内(1至15)的线程优先级</li>
</ul>
</li>
</ul>
<h3 id="LINUX_进程调度">LINUX 进程调度</h3><ul>
<li>实时进程<ul>
<li>对调度延迟的要求最高， 要求立即响应并执行</li>
<li>调度策略： FIFO， RR</li>
</ul>
</li>
<li>普通进程<ul>
<li>交互式进程： 间或处于睡眠态， 对响应速度要求高</li>
<li>批处理进程： 后台执行， 能忍受响应延迟</li>
<li>普通进程调度策略： CFS 完全公平调度算法</li>
</ul>
</li>
</ul>
<h4 id="linux2-4调度算法">linux2.4调度算法</h4><ul>
<li>单就绪队列+时间片+优先级</li>
<li>对 runqueue中所有进程的优先级依次进行比较，选择最高优先级的进程作为下一个被调度的进程</li>
<li>创建时进程赋予它一个时间片。时钟中断时递减当前运行进程的时间片，进程的时间片用完时，它必须等待重新赋予时间片才能有机会运行</li>
<li>只有当所有 RUNNING 进程的时间片都用完之后，才对所有进程重新分配时间片。这种设计保证了每个进程都有机会得到执行</li>
<li>counter(时间片)越大，优先级越高<ul>
<li>时间片指的就是 counter 值，每个进程的可能不一样。而且实时进程的 counter 用完之后会立刻重置 counter 然后放入就绪队列，而非实时进程要等待 runqueue 中为空 时，统一重新计算 counter</li>
<li>普通进程的优先级主要由进程描述符中的 counter 字段决定 (再实时进程要等待runqueue中为空 时，统一重新计算counter要加上 nice 设定的静态优先级)</li>
<li>nice 从最初的 UNIX 沿用而来，表示进程的静态负向优先级，取值范围为 19~-20，以-20优先级最高        </li>
</ul>
</li>
<li>缺点：<ul>
<li>可扩展性不好</li>
<li>高负载系统上的调度性能比较低</li>
<li>交互式进程的优化并不完善</li>
<li>实时进程支持度不够</li>
</ul>
</li>
<li>O(1) 调度器改进<ul>
<li>优先级计算方法</li>
<li>pick next 算法</li>
</ul>
</li>
<li>楼梯调度算法 SD<ul>
<li>抛弃动态优先级， 采取完全公平思路</li>
<li>为每一个优先级维护一个进程列表，并将这些列表组织在 active 数组中，当选取下一个要调度进程时， SD算法也同样从 active 数组中直接读取</li>
<li>用完时间片后下降一级， 降到最低一级后回到初始优先级的下一级队列</li>
<li>能避免饥饿， 交互式进程睡眠时， 同等级进程下楼后， 交互式进程苏醒后仍在高处能快速调度</li>
</ul>
</li>
<li>RSDL 对 SD 的改进<ul>
<li>核心： 完全公平</li>
<li>引入 expired 数组</li>
<li>为每个优先级分配一个 “组时间配额” Tg（耗尽后全部下降）</li>
<li>同一优先级的每个进程都拥有同样的“时间配额” Tp （耗尽后自己下降一级优先级）</li>
<li>Tp 与进程的时间片不同，时间片用完后进程直接进入expired数组，一般有 Tp &lt; time_slice， 回到初始优先级队列</li>
</ul>
</li>
</ul>
<h4 id="CFS（Completely_Fair_Scheduling）">CFS（Completely Fair Scheduling）</h4><ul>
<li>完全公平思想:每个进程获得1/n的时间片时间</li>
<li>每个进程有一个“虚拟运行时间”（vruntime, 已经跑了多久）， 调度器会的选择虚拟运行时间最小的进程允许， 与运行时间成正比， 优先级成反比。</li>
<li>虚拟运行时间组织成一棵红黑树,cached最左进程O(1)，调度O(logn)（/linux/include/linux/sched.h）</li>
<li>调度周期：将所有可调度进程全部调度一遍的时间</li>
<li>分配给某个进程p的运行时间，按权重等比例分配。权重：按nice值算出prio_to_weight (/kernel/sched/core.c)</li>
<li>vruntime = (tp/wp)*NICE_O_LOAD</li>
<li>进程更换CPU时的vruntime策略：/kernel/sched/fair.c migrate_task_rq_fair()</li>
</ul>
<h4 id="BFS">BFS</h4><ul>
<li>virtual deadline = jiffies + (user_priority * rr_interval)</li>
<li>优先级顺序：realtime/sched_iso/sched_normal/sched_idleprio</li>
<li>利用bitmap维护一个进程队列头指针的数据结构，依次遍历bitmap的低位到高位，存放优先级从高到低的进程队列</li>
<li>选择virtual deadline最小的进程</li>
<li>进程wakeup：抢占/插入，sleep：VD不变，用完时间片：重新计算VD</li>
</ul>
<h4 id="实时系统调度算法">实时系统调度算法</h4><ul>
<li>静态调度：RMS<ul>
<li>基于优先级的抢占式调度</li>
<li>给所有任务静态分配优先级</li>
</ul>
</li>
<li>动态调度<ul>
<li>EDF：最早截止时间优先算法<ul>
<li>维护一个ddl队列，每次取队列头调度</li>
</ul>
</li>
<li>LLF：最低松弛度优先算法<ul>
<li>松弛度=ddl-当前时间-任务完成还需要的时间</li>
<li>维护松弛度序列，每次取队列头进行调度</li>
<li>抢占当且仅当松弛度为0，否则会超过ddl</li>
<li>如果松弛度相同，选择最久未调度的进程调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多处理器调度">多处理器调度</h3><ul>
<li>对称多处理器：<ul>
<li>每个处理器运行自己的调度程序</li>
<li>对处理器共享资源进程同步</li>
</ul>
</li>
<li>调度算法设计<ul>
<li>需要决定在哪个 CPU 上执行</li>
<li>需要考虑进程在多个 CPU 之间迁移的开销<ul>
<li>缓存， TLB 失效</li>
<li>尽可能使进程在同一个 CPU 上运行</li>
</ul>
</li>
<li>考虑负载均衡         </li>
</ul>
</li>
</ul>
<h1 id="第五讲">第五讲</h1><h2 id="并发环境">并发环境</h2><ul>
<li>顺序环境：只有一个程序运行， 独占所有资源， 不受外界影响<ul>
<li>封闭性：独占资源， 执行时不受外界影响</li>
<li>结果的确定性</li>
<li>调度顺序不重要 </li>
</ul>
</li>
<li>并发环境<ul>
<li>程序执行结果不可再现性： 结果与相对速度有关， 不确定</li>
<li>在并发环境下执行是间断的</li>
<li>资源共享： 系统中资源被多个进程使用</li>
<li>独立性和制约性</li>
<li>程序和计算不再一一对应  </li>
</ul>
</li>
<li>竞争条件<ul>
<li>读写共享资源最终结果取决于进程运行的精确时序</li>
</ul>
</li>
<li>进程互斥： 由于个进程要求使用共享资源， 而这些资源需要排他性使用， 各进程之间竞争使用这些资源<ul>
<li>临界资源： 系统中某些资源一次只允许一个进程使用， 这样的资源称为 <strong>临界资源</strong> 或 <strong>互斥资源</strong> 或 <strong>共享变量</strong></li>
<li>临界区（互斥区）： 各个进程中对某个临界资源实时操作的程序片段<ul>
<li>没有进程在临界区， 想进入临界区的进程可以进入</li>
<li>不允许两个进程同时处于其临界区</li>
<li>临界区外运行的进程不得阻塞其他进程进入临界区</li>
<li>不得使进程无限期等待进入临界区</li>
</ul>
</li>
</ul>
</li>
<li>进程的同步： 多个进程中发生的事件存在某种时序关系，需要相互合作， 共同完成一项任务</li>
</ul>
<h3 id="进程互斥的解决方案">进程互斥的解决方案</h3><ul>
<li>软件方案：<ul>
<li>Dekker 算法</li>
<li>Peterson 算法</li>
</ul>
</li>
<li>硬件方案：<ul>
<li>“开关中断”指令<ul>
<li>简单高效， 代价高， 限制 CPU 并发能力</li>
<li>不适用于多处理器</li>
<li>适用于操作系统本身， 不适用于用户进程</li>
</ul>
</li>
<li>“测试并加锁”指令</li>
</ul>
</li>
<li>以上解决方案会导致<strong>忙等待</strong><ul>
<li>自旋锁 Spin lock （多处理器使用忙等待：可能其他 CPU 会在忙等待期间开锁， 尽可能避免进程切换带来的开销）</li>
</ul>
</li>
<li>临界区导致的优先级反转</li>
</ul>
<h3 id="生产者/消费者问题">生产者/消费者问题</h3><ul>
<li>又称为有界缓冲区问题</li>
<li>睡眠与唤醒原语， 避免忙等待。</li>
</ul>
<h3 id="典型的同步机制">典型的同步机制</h3><h4 id="信号量和_PV_操作">信号量和 PV 操作</h4><ul>
<li>test&amp;set指令会锁住总线，是一条比较贵的指令</li>
<li>信号量：<ul>
<li>一个特殊变量</li>
<li>用于进程间传递信号的一个整数值（semaphore）</li>
<li>结构体：count/queue</li>
</ul>
</li>
<li>P/V操作：<ul>
<li>P操作：<ul>
<li>s.count–</li>
<li>if s.count &lt; 0：<ul>
<li>进程进入阻塞状态，并将进程插入等待队列s.queue的末尾</li>
<li>reschedule()</li>
</ul>
</li>
</ul>
</li>
<li>V操作：<ul>
<li>s.count++</li>
<li>if s.count &lt;= 0：<ul>
<li>唤醒s.queue中的一个进程，</li>
<li>改变状态为就绪态，并插入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>定义及性质<ul>
<li>P/V操作为原语操作（执行过程中不允许中断）</li>
<li>在信号量上定义了三个操作：初始化（非负数）/P操作/V操作</li>
<li>最初提出二元信号量（互斥原则），之后推广到了一般信号量（0/1，多值）或计数信号量（semaphore&gt;1，解决同步问题）</li>
</ul>
</li>
<li>用P/V操作解决进程间互斥问题<ul>
<li>分析并发进程的关键活动，划定临界区</li>
<li>设置信号量mutex，初值为1</li>
<li>在临界区前实施P(mutex)，临界区后实施V(mutex)</li>
</ul>
</li>
<li>解决生产者消费者问题（同步问题）<ul>
<li>定义三个信号量：(Initialize)<ul>
<li>mutex = 1: 互斥信号量，控制对临界区的访问</li>
<li>empty = N: 空缓冲区个数信号量</li>
<li>full = 0: 满缓冲区个数信号量</li>
</ul>
</li>
<li>producer进程产生item后P(empty)然后P(mutex),首先P一个空缓冲区，接着P一个互斥互斥锁，在insert操作后，V掉mutex再V出一个full，表示生产出了一个可用的满缓冲区。</li>
<li>cosumer进程在获取要消耗的item前需要P掉一个full，再P掉mutex，随后获取remove的item，接着V掉mutex，再V掉一个empty，表示一个item已被消耗。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="管程">管程</h4><ul>
<li>为什么引入管程？信号量机制的不足：程序编写困难/效率低</li>
<li>一个程序设计的语言成分，高级同步操作</li>
<li>定义：<ul>
<li>是一个特殊的模块</li>
<li>由关于共享资源的数据结构及在其上操作的一组过程组成</li>
<li>进程与管程：进程只能通过调用管程中的过程来间接的访问管程中的数据结构</li>
</ul>
</li>
<li>互斥：<ul>
<li>管程是互斥进入的：为了保证管程中数据结构的完整性</li>
<li>管程的互斥性是由编译器负责保证的</li>
</ul>
</li>
<li>同步：<ul>
<li>管程中设置条件变量及等待/唤醒操作以解决同步问题</li>
<li>可以让一个进程或线程等待在条件变量上等待（此时应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒。</li>
</ul>
</li>
<li>允许多个进程同时在管程中<ul>
<li>问题：一个进程进入管程执行等待操作，释放了管程的互斥权。而后面进入管程的进程执行唤醒操作时（例如P唤醒Q），进程中便存在两个同时处于活动状态的进程</li>
<li>解决：<ul>
<li>P等待Q执行(Hoare)</li>
<li>Q等待P继续执行(MESA)</li>
<li>规定唤醒为管程中最后一个可执行的操作(Hansen)</li>
</ul>
</li>
<li>Hoare管程<ul>
<li>条件变量：在管程内部说明和使用的一种特殊类型变量<ul>
<li>可以执行wait和signal操作</li>
<li>wait(c):如果紧急等待队列非空，则唤醒第一个等待者，否则释放管程的互斥权，执行此操作的进程进入c队列尾部</li>
<li>signal(c):如果c队列为空，相当于空操作；如果非空则唤醒第一个c队列中的等待者。 </li>
<li>用管程解决生产者消费者问题<ul>
<li>条件变量：full/empty，count计数</li>
<li>insert过程：<ul>
<li>if count == N: wait(full); </li>
<li>insert(item); count++;</li>
<li>if count == 1: signal(empty);</li>
</ul>
</li>
<li>remove过程：<ul>
<li>if count == 0: wait(empty);</li>
<li>remove = remove_item; count–;</li>
<li>if count == N-1: signal(full);</li>
</ul>
</li>
</ul>
</li>
<li>管程实现的途径：直接构造/间接构造：用某种已经实现的同步机制去构造（例子：信号量P/V操作实现管程，PPT读者写者问题）</li>
</ul>
</li>
</ul>
</li>
<li>Mesa管程<ul>
<li>Hoare管程：signal的缺陷<ul>
<li>两次额外的进程切换</li>
<li>是否会使条件队列中的进程永久挂起？</li>
</ul>
</li>
<li>解决：signal-&gt;notify<ul>
<li>notify(x)：当一个正在管程中的进程执行notify(x)时，会使x等待队列中的队首进程进入就绪状态，在CPU可用时调度上CPU</li>
<li>注意需要用while判断条件，因为不保证在等待过程中没有其他进程进入管程</li>
<li>further改进：broadcast(x)：notify在条件变量x上等待的所有进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PTHREADS：锁（解决互斥问题）/条件变量_（解决同步问题）">PTHREADS：锁（解决互斥问题）/条件变量 （解决同步问题）</h4><ul>
<li>锁（互斥量）<ul>
<li>提供两个过程：上锁和解锁</li>
<li>即mutex：互斥量</li>
<li>注意两个过程函数：<ul>
<li>Pthread_mutex_lock: acquire a lock or block</li>
<li>Pthread_mutex_trylock: acquire a lock or fail</li>
</ul>
</li>
</ul>
</li>
<li>条件变量</li>
<li>Pthread_cond_wait(&amp;condp, &amp;mutex)/Pthread_cond_signal()<ul>
<li>先解锁</li>
<li>然后等待唤醒信号</li>
<li>然后上锁</li>
</ul>
</li>
<li>先lock mutex因为在判断buffer是否非空的时候被打断会出现问题</li>
<li>判断条件用while而不是if，因为在wakeup之后可能会出现条件发生改变的情况</li>
</ul>
<h4 id="第一类读者写者问题">第一类读者写者问题</h4><ul>
<li>增加并发性：不需要所有的读者都P&amp;V</li>
<li>只需要第一个读者P最后一个读者V即可</li>
<li>添加计数器rc <ul>
<li>rc++; </li>
<li>if rc==1: P(w);</li>
<li>{…   rc–; }</li>
<li>if rc==0: V(w);</li>
</ul>
</li>
</ul>
<h4 id="锁的实现">锁的实现</h4><ul>
<li>lock():<ul>
<li>disable interrupts</li>
<li>if(value == FREE):<ul>
<li>value = BUSY</li>
</ul>
</li>
<li>else:<ul>
<li>添加线程等待该锁</li>
<li>切换至下一个可运行线程</li>
</ul>
</li>
<li>enable interrupts</li>
</ul>
</li>
<li>硬件解法：忙等待，一直占用CPU等待锁</li>
<li>用户态解法：主动让出（yield）</li>
</ul>
<h4 id="通信机制">通信机制</h4><ul>
<li>解决信号量及管程的不足/多处理器情况下原语失效的问题</li>
<li>基本通信方式：消息传递/共享内存/管道/套接字/远程过程调用（RPC）</li>
<li><strong>消息传递</strong><ul>
<li>send(dest, message)/recieve(src, message)</li>
<li>消息缓冲区：消息头/消息体组成一个消息结构体</li>
<li>发送者执行send()，陷入内核，将消息复制给消息缓冲区，再将消息结构体指针入队（接收进程的PCB中的消息队列）。接收者执行receive()，将内核中的相应的消息取回。</li>
<li>同样可以用消息传递的方式实现生产者消费者问题：<ul>
<li>生产者recieve(cousumer, &amp;m); m = build_message(); send(cosumer, &amp;m);</li>
<li>消费者先send一些空message给生产者，然后recieve(producer, &amp;m); m = extract_message(); send(producer, &amp;m);</li>
</ul>
</li>
</ul>
</li>
<li><strong>共享内存</strong><ul>
<li>进程的某一片地址空间映射到同一片物理内存</li>
<li>相互通信的进程间需要建立公共内存区域，从而实现信息传递</li>
</ul>
</li>
<li><strong>管道（pipe）</strong><ul>
<li>利用一个缓冲传输介质——内存或文件连接两个相互通信的进程</li>
<li>字符流方式写入写出</li>
<li>管道通信机制必须提供的协调能力：互斥/同步/接收进程是否存在</li>
</ul>
</li>
<li><strong>套接字</strong></li>
</ul>
<h1 id="第五讲-1">第五讲</h1><h2 id="死锁">死锁</h2><ul>
<li>一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到资源，这种现象被称为进程死锁，这组进程被称为死锁进程</li>
<li>为什么会出现死锁？资源数量有限/锁和信号量使用错误</li>
<li>可重用资源：可以被多个进程重复使用</li>
<li>可抢占资源/不可抢占资源</li>
<li>可消耗资源：只可使用一次的可以创建和销毁的资源</li>
<li>活锁与饥饿的区别：活锁加锁，轮询，没有进展也没有阻塞；饥饿：资源分配策略决定</li>
<li>产生死锁的必要条件：<ul>
<li>互斥使用</li>
<li>占有且等待（请求和保持， 部分分配）： 已有部分资源， 还需要新的资源</li>
<li>不可抢占（不可剥夺）：资源申请者不能从占有者手中抢夺</li>
<li>循环等待： P1 等 P2， P2 等 P3， ….. ,Pn 等 P1</li>
</ul>
</li>
</ul>
<h2 id="资源分配图（RAG）">资源分配图（RAG）</h2><ul>
<li>用有向图描述资源系统和进程的状态</li>
<li>资源类：用方框表示，进程实例：用方框中的黑圆点表示，进程用圆圈表示</li>
<li>带方向的箭头表示进程对资源的占有和请求</li>
<li>死锁定理：资源分配中没有环路，则系统中没有死锁。如果图中存在环路那么可能会存在死锁。</li>
<li>如果每个资源类中只有一个资源实例，则环路是死锁存在的充分必要条件。</li>
<li>图的化简：<ul>
<li><ol>
<li>找一个非孤立点进程节点且只有分配边，删去该边和相应的边</li>
</ol>
</li>
<li>2.？？？</li>
<li>重复 1/2</li>
</ul>
</li>
</ul>
<h2 id="死锁解决">死锁解决</h2><h3 id="不考虑此问题_——_鸵鸟算法">不考虑此问题 —— 鸵鸟算法</h3><h3 id="阻止死锁发生">阻止死锁发生</h3><ul>
<li>死锁预防： 静态策略——设计和事的资源分配算法，不让死锁发生<ul>
<li>破坏产生死锁的条件<ul>
<li>破坏 互斥使用 条件<ul>
<li>资源转换技术： 独占变为共享资源</li>
<li>SPOOLing 技术： 设计一个 ”精灵daemon“ 进程/线程负责管理打引进，进程需要打印时，将请求发给该 daemon， 由它完成打印任务</li>
</ul>
</li>
<li>破坏 占有且等待 条件<ul>
<li>方案1: 要求每个进程必须一次性申请它所要求的所有资源， 均可满足时才分配<br><br>问题： 资源利用率低， “饥饿”</li>
<li>方案2: 在允许进程动态申请资源前提下规定， 在拿不到资源进入等待之前， 必须释放已占有的全部资源， 若需要则重新申请</li>
</ul>
</li>
<li>破坏 不可抢占 条件<ul>
<li>实现方案： 虚拟化资源</li>
<li>当一个进程申请的资源被其他进程占用时， 可以通过操作系统抢占这一资源（优先级不同）</li>
<li>局限性： 适用于状态易于保存（CPU， 内存）和恢复的资源 </li>
</ul>
</li>
<li>破坏 循环等待 条件<ul>
<li>实现方案： 资源有序分配法</li>
<li>系统中资源标号， 申请时必须按递增次序进行</li>
<li>实现时的问题： 资源如何编号            </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>死锁避免： 动态策略——以不让死锁发生为目标，跟踪并评估资源分配过程， 根据评估结果决策是否分配<ul>
<li>定义： 在系统运行过程中， 对每一个资源申请进行同台检查，根据检查结果决定是否分配， 若可能死锁则不予分配，否则于一分配</li>
</ul>
</li>
</ul>
<pre><code>-<span class="ruby">     安全状态： 如果存在一个由系统中所有进程构成的安全序列 <span class="constant">P1</span>,...,<span class="constant">Pn</span> 则系统是安全的
</span>-<span class="ruby">    安全序列： 一个进程序列是安全的， 如果对于每一个 <span class="constant">Pi</span>， 它**以后尚需要的资源量**不超过系统当前剩余的资源量与前面进程**当前占有**资源量之和（即在前面进程返还资源后能满足要求）， 系统处于安全状态
</span>-<span class="ruby">     不安全状态： 不存在一个安全序列。
</span>-<span class="ruby">      不安全状态一定导致死锁（但不代表已经死锁）
</span>
-<span class="ruby">      银行家算法： 仿照银行发放贷款时采取的控制方式而设计的一种死锁避免算法
</span>    -<span class="ruby">    系统具有的特征：
</span>        -<span class="ruby">    在固定数量的进程中故乡数量固定的资源
</span>        -<span class="ruby">     每个进程预先制定完成工作所需要的最大资源量
</span>        -<span class="ruby">      进程不能申请比系统中可用资源总数还多的资源
</span>        -<span class="ruby">      进程等待资源的时间是有限的
</span>        -<span class="ruby">      如果系统满足了进程对资源的最大需求， 那么进程应该在有限时间内使用资源然后返还
</span>    -<span class="ruby">    n 进程总数， m 资源类总数
</span>    -<span class="ruby">     available array[<span class="number">1</span>~m] 
</span>        &lt;br&gt; max [n][m]
        &lt;br&gt; allocation [n][m]
        &lt;br&gt; need [n][m]
        &lt;br&gt; request [n][m] (这一次申请)
        &lt;br&gt; 简写时忽略资源维度
        -<span class="ruby">    （<span class="number">1</span>） <span class="keyword">if</span> request[i] ≤ need[i]
</span>            &lt;br&gt; 转（2） &lt;br&gt; else 返回错误
        -<span class="ruby">    （<span class="number">2</span>） <span class="keyword">if</span> request[i] ≤ avaliable &lt;br&gt; 转(<span class="number">3</span>) &lt;br&gt; <span class="keyword">else</span> 等待
</span>        -<span class="ruby">      (<span class="number">3</span>) 进行分配运算 修改各个数据结构
</span>    -<span class="ruby">    检查安全状态
</span>        -<span class="ruby">    work[m] 
</span>        -<span class="ruby">     finish[n] （进程是否结束）
</span>        -<span class="ruby">     (<span class="number">1</span>)work = avaliable &lt;br&gt; finish = <span class="keyword">false</span>
</span>        -<span class="ruby">  (<span class="number">2</span>)寻找满足条件的 i &lt;br&gt; finish[i] == <span class="keyword">false</span> &amp;&amp; need[i] ≤ work &lt;br&gt;不存在转到(<span class="number">4</span>)
</span>        -<span class="ruby">  (<span class="number">3</span>)work += allocation[i] &lt;br&gt; finish[i] = <span class="keyword">true</span> &lt;br&gt; 转(<span class="number">2</span>)
</span>        -<span class="ruby">  (<span class="number">4</span>)若所有的i， finish[i] == <span class="keyword">true</span>, 则处于安全状态</span>
</code></pre><h3 id="让死锁发生_——_死锁检测与解除">让死锁发生 —— 死锁检测与解除</h3><ul>
<li>允许死锁发生， 操作系统不断监视系统进展情况， 判断死锁是否发生</li>
<li>一旦死锁发生则采取专门的措施， 解除死锁并以最小的代价恢复操作系统运行</li>
<li>检测时机：<ul>
<li>当进程由于资源请求不满足而等待时检测死锁（缺点： 系统开销大）</li>
<li>定时监测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
</li>
<li>一个简单的死锁检测算法<ul>
<li>每个进程和资源编号</li>
<li>设置一张资源分配表记录各进程与其占用的资源之间的关系</li>
<li>设置一张进程等待表记录各进程与要申请的资源之间的关系</li>
<li>用两张表判断是否形成回路</li>
</ul>
</li>
<li>死锁解除：<ol>
<li>撤销所有死锁进程（开销大）</li>
<li>进程回退再启动(开销大)</li>
<li>按照某种原则逐一撤销死锁进程，直到…</li>
<li>按照某种原则逐一抢占资源(资源被抢占的进程必须回退到之前的对应状态),直到… </li>
</ol>
</li>
</ul>
<h3 id="哲学家就餐问题">哲学家就餐问题</h3><h4 id="为防止死锁发生可采取的措施">为防止死锁发生可采取的措施</h4><ul>
<li>最多允许四个哲学家同时坐在桌子旁</li>
<li>仅当一个哲学家左右两边的筷子都可用时，才允许他拿筷子</li>
<li>给所有哲学家编号，奇数号必须先拿左， 偶数号必须先拿右</li>
</ul>
<h1 id="第八讲_基本内存管理">第八讲 基本内存管理</h1><h2 id="物理内存管理方案">物理内存管理方案</h2><h3 id="空闲内存管理">空闲内存管理</h3><ul>
<li>数据结构<ul>
<li>位图（等长）： 每个分配单元对应于图中的一个位， 0 空闲， 1 占用（或相反）</li>
<li>空闲区表： 每一项纪录空闲去的起始地址， 长度， 下一个块</li>
<li>空闲表</li>
</ul>
</li>
<li>分配算法<ul>
<li>首次适配</li>
<li>下次适配</li>
<li>最佳适配</li>
<li>最差适配</li>
</ul>
</li>
</ul>
<h3 id="伙伴系统_（Linux_底层内存管理采用）">伙伴系统 （Linux 底层内存管理采用）</h3><ul>
<li>一种经典的内存分配方案， 一种特殊的“分离适配”算法</li>
<li>主要思想： 将内存按2的幂次进行划分， 组成若干空闲块链表， 查找该链表找到能满足进程需求的最佳匹配块</li>
<li>一开始整个一块<br> <br> 大小大于一半-&gt; 全部分配<br> <br> 否则划成一半， 重复过程</li>
<li>不是伙伴的块不进行合并</li>
</ul>
<h2 id="基本内存管理方案（逻辑空间）">基本内存管理方案（逻辑空间）</h2><ul>
<li>单一连续块： 每次只允许一个程序， 独占全部内存， 总被加载到同一个内存地址</li>
<li>固定分区： 划分若干区域</li>
<li>可变分区： 根据进程需求， 从内存空间分割出一个分区分配给该进程<ul>
<li>紧缩技术： 在内存移动程序， 将所有小的空闲区合并为较大的空闲区</li>
<li>正在 I/O 的进程不能移动</li>
</ul>
</li>
<li>页式： 逻辑空间按页（和物理空间大小相同）分配成大小相同的区域， 逻辑相邻的页物理不一定相邻<ul>
<li>物理页面 page fream 又称页框 页帧</li>
<li>虚拟页面 page 又称 页   </li>
</ul>
</li>
<li>段式： 按进程逻辑分若干段， 内存动态化分若干不等长区域<ul>
<li>逻辑地址： 段号+段内地址</li>
<li>段表： 段的起始地址 + 段长度   </li>
</ul>
</li>
<li>段页式<ul>
<li>段中分页， 物理内存管理比较简单（克服段式缺点）</li>
</ul>
</li>
</ul>
<h2 id="内存扩充">内存扩充</h2><ul>
<li>目标： 在较小储存空间运行较大程序时遇到的矛盾</li>
<li>内存紧凑（没有空间是假象）</li>
<li>覆盖技术<ul>
<li>程序执行过程中， 程序的不同部分在内存中相互替代（如 if else 不会同时执行）</li>
<li>按照自身逻辑结构将那些不会同时执行的程序段共享同一块内存区域</li>
<li>要求程序各模块之间有明确的调用结构</li>
<li>程序员声明覆盖结构， 操作系统完成覆盖</li>
<li>缺点：<ul>
<li>编程困难</li>
<li>效率低     </li>
</ul>
</li>
</ul>
</li>
<li>交换技术<ul>
<li>将内存某些进程暂时移到外存， 把外存某些进程换进来</li>
<li>进程的什么部分交换到磁盘<ul>
<li>有的部分是磁盘中本来就有， 有的部分是动态产生的</li>
<li>运行时创建或修改的内容： 堆和栈 （这部分是产生的）</li>
</ul>
</li>
<li>有部分动态产生的写回到什么位置<ul>
<li>一般系统会指定一块特殊的磁盘区域作为交换空间， 包含连续的磁道， 操作系统可以使用底层的磁盘读写对其高效访问 </li>
</ul>
</li>
<li>交换时机<ul>
<li>只要不用就换出（很少再用）</li>
<li>内存空间不够或有不够的危险时就换出</li>
<li>与调度器结合使用  </li>
</ul>
</li>
<li>如何选择被换出的进程<ul>
<li>考虑进程的各种属性； 不应换出处于 I/O 等待的进程   </li>
</ul>
</li>
<li>换出后再换入的进程是否回到原处<ul>
<li>不一定， 采用动态重定位   </li>
</ul>
</li>
<li>如何处理进程空间增长<ul>
<li>栈和堆相向而长         </li>
</ul>
</li>
</ul>
</li>
<li>虚存技术</li>
</ul>
<h2 id="页式管理">页式管理</h2><ul>
<li>页表项： 记录了逻辑页号和页框号的对应关系</li>
<li>每个进程一个页表， 存放在内存</li>
<li><p>页表的起始地址保存在 context 中</p>
</li>
<li><p>地址转换（硬件支持）</p>
<ul>
<li>CPU 取到逻辑地址， 自动划分为页号和页内地址， 用页号查页表， 得到页框号， 再与页内地址拼接为物理地址</li>
</ul>
</li>
</ul>
<h1 id="第九讲_虚拟页式管理">第九讲 虚拟页式管理</h1><ul>
<li>操作系统对存储的抽象： 地址空间</li>
<li>操作系统协调各存储器的使用</li>
<li>虚拟内存<ul>
<li>构建在存储体系之上</li>
<li>提供给用户进程一个幻象</li>
<li>一个比物理内存空间大的多的地址空间</li>
<li>满足： 地址独立， 地址保护</li>
</ul>
</li>
<li>虚存<ul>
<li>内存和磁盘结合使用得到一个容量很大的“内存”</li>
<li>受寻址机制和可用磁盘容量限制</li>
</ul>
</li>
<li>当进程运行时， 先将一部分装入内存， 另一部分暂时保存在磁盘， 当要执行的指令或访问的数据不在内存时， 由操作系统将他们从磁盘装在进来</li>
</ul>
<h2 id="虚拟页式存储管理">虚拟页式存储管理</h2><ul>
<li>基本思想<ul>
<li>装载程序时， 不是装入全部页面， 而是装入几个或零个页面</li>
<li>如果进程执行时需要的页面不在内存， 则动态装入所需</li>
<li>需要时， 将内存中暂时不用的一些页面交换到磁盘以便获得更多的内存空间</li>
</ul>
</li>
<li>通常有两种方式<ul>
<li>请求调用</li>
<li>预先调页              </li>
</ul>
</li>
<li>MMU： 内存管理单元</li>
<li></li>
<li>如何处理页表巨大的问题</li>
<li>地址重定位与快表（TLB）</li>
<li>一种最常见的 Page Fault -&gt; 缺页中断</li>
<li>驻留集管理</li>
<li>置换策略</li>
<li>清楚策略</li>
<li>加载控制</li>
</ul>
<h2 id="页表表项的设计">页表表项的设计</h2><ul>
<li>页框号PFN</li>
<li>有效位P： 表示该页是在内存还是在磁盘</li>
<li>访问位A： 引用位</li>
<li>修改位D： 页面是否被修改过</li>
<li>保护位（读/写/执行）</li>
</ul>
<ul>
<li>一个进程的页表的各页在内存中若不连续存放， 则需要引入地址索引 -&gt; 页目录</li>
<li>注意： 页表本身也放在虚存中（进程运行时， 部分页表映射到内存）</li>
<li>两级页表： 顶级页表起始地址放在 context 中， 加载到内存</li>
<li>虚拟地址-&gt; 页目录偏移（10） + 页表偏移（10）+ 页内偏移（12）<ul>
<li>64位（实际只有48位地址使用）： 每个表项64位， 四级页表 9 + 9 + 9 + 9（地址翻倍长度， 能存的数量减半） + 12</li>
</ul>
</li>
<li><p>引入反转页表： 从物理地址指向虚拟地址</p>
<ul>
<li>从物理地址空间出发， 系统建立一张页表</li>
<li>页表项纪录进程 i 的某虚拟地址与页框号的映射关系</li>
<li>直放：    由 vpn 得到一个物理表项， 如果冲突， 另行计算<ul>
<li>对应物理位置放入 pid 和 vpn 信息 （虚拟地址： vpn + offset）</li>
<li>取的时候找 vpn 相同的 再检验pid</li>
</ul>
</li>
<li>用 pid 和 vpn 做 hash确定表项<ul>
<li>查询的时候效率比较高</li>
</ul>
</li>
<li>PowerPC， UltraSPSRC 和 IA-64使用</li>
<li>页表大小和物理内存相关和地址无关。            </li>
</ul>
</li>
<li><p>地址转换（硬件机制）</p>
<ul>
<li>页面不在内存/页面非法/页面受到保护…<br><br> 硬件产生一程 page fault</li>
<li>否则 页框号 = 页表[虚页号]； 物理地址 = 页框号 + 页内偏移</li>
</ul>
</li>
<li><p>快表（TLB）的引入</p>
<ul>
<li>页表-&gt;两次获两次以上的内存访问</li>
<li>CPU 的指令处理速度与内存指令的访问速度差异大， CPU 速度得不到充分利用</li>
<li>相联存储器， 按内容<strong>并行</strong>查找（一个周期内同时查找所有项）</li>
<li>保存正在进行进程的页表的子集（部分表项）</li>
</ul>
</li>
</ul>
<h2 id="缺页异常处理">缺页异常处理</h2><ul>
<li>有空闲页框-&gt;分配， 内存中没有空闲页， 置换（修改过的部分要写会）</li>
</ul>
<h2 id="驻留集管理">驻留集管理</h2><ul>
<li>驻留集大小： 给每个进程分配多少页框</li>
<li>固定分配策略</li>
<li>可变分配策略<ul>
<li>根据缺页率评估进程局部性表现</li>
<li>高-&gt; 增加/ 低-&gt; 减少</li>
<li>系统开销</li>
</ul>
</li>
<li>置换问题<ul>
<li>置换范围<ul>
<li>局部/全局</li>
<li>固定分配职能使用局部置换 </li>
</ul>
</li>
<li>置换策略    <ul>
<li>放置 （分配）</li>
<li>置换 （替换/淘汰）</li>
<li>所有策略的目标 -&gt; 置换最近最不可能访问的页</li>
<li>根据局部性原理： 最近的访问历史和最近将要访问的模式间存在相关性， 因此， 大多数策略都基于过去的行为来预测将来的行为</li>
<li>注意： 置换策略设计得越精致复杂， 实现的软硬件开销就越大</li>
<li>约束： 不能置换被锁定的页框<ul>
<li>例如： 操作系统核心代码， 关键数据结构， I/O 缓冲区</li>
<li>用户进程锁定的上限有限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>页面置换算法<ul>
<li>最优置换算法 OPT<ul>
<li>设计思想： 置换以后不再需要的或最远的将来才会使用的页面</li>
<li>实现： 无法实现</li>
<li>作用： 作为标杆， 接近这个算法的算法就比较好</li>
</ul>
</li>
<li>先进先出<ul>
<li>选择再内存中驻留时间最长的页置换 （参照： 超市撤换商品）</li>
<li>实现：页面链表法</li>
</ul>
</li>
<li>第二次机会只换算法 SCR<ul>
<li>按照先进先出算法选择某一页面， 检查其访问位 R， 如果为 0， 则置换该页； 如果为 1， 则给第二次机会， 并将访问位置 0</li>
</ul>
</li>
<li>时钟算法 Clock（一种实现方式而不是算法设计）<ul>
<li>移动指针来选择页框</li>
<li>实现： 优先选择不需要写回的</li>
</ul>
</li>
<li>最近未使用算法（NRU）<ul>
<li>选择在最近一段时间内未使用过的一页纸换</li>
<li>实现： 设置页表表项的两位： 访问（R）， 修改（M）</li>
<li>启动一个进程时， R， M 置为 0， R位定期清零（复位）， 修改后 M 置 1<ul>
<li>0:    无访问无修改</li>
<li>1:     无访问有修改</li>
<li>2：    有访问无修改</li>
<li>3：    有访问有修改</li>
<li>从上到下一次选， 从同一类中随机选择 </li>
</ul>
</li>
</ul>
</li>
<li>最近最少使用 LRU<ul>
<li>选择最后一次访问时间距离当前时间最长的一页置换</li>
<li>性能接近 OPT</li>
<li>实现： 时间戳 或 维护一个访问页的栈<ul>
<li>开销大</li>
</ul>
</li>
<li>硬件实现 n x n 矩阵<ul>
<li>访问时把对应行置 1， 对应列置 0， （k，k）值位0</li>
<li>把值最小的行换出对应的页面换出</li>
</ul>
</li>
</ul>
</li>
<li>最不经常使用算法 NFU<ul>
<li>但选择访问次数最少的页面置换</li>
<li>LRU 的一种软件解决方案（提出者声称）</li>
<li>实现：<ul>
<li>软件计数器， 一页一个， 初始为0  </li>
<li>每次时钟中断： 计数器加 R（被访问的）</li>
<li>发生缺页时， 选择计数器值最小的置换</li>
</ul>
</li>
</ul>
</li>
<li>老化算法 Aging （改进 NFU）<ul>
<li>模拟 LRU： 计数器在加 R 前先右移一位， R 加在技术起的最左端（高位）</li>
</ul>
</li>
</ul>
</li>
<li><p>Belady 现象：</p>
<ul>
<li>系统给某进程分配 m 个页框， 并不是 m 越大缺页越少（某些算法产生的异常现象）</li>
<li>如： 用 FIFO， 考虑 1 2 3 4 1 2 5 1 2 3 4 5， m = 3 / 4 时， m=4 缺页10次， m=3 缺页9词</li>
<li>算法满足栈式算法则不会产生这样的异常现象（如 LRU）</li>
</ul>
</li>
<li><p>影响缺页次数的因素</p>
<ul>
<li>页面置换算法</li>
<li>页面本身的大小<ul>
<li>页面尺寸问题<ul>
<li>是硬件指标， 对于操作系统是个可选参数</li>
<li>多种页面尺寸， 为有效使用 TLB 带来灵活性， 但给操作系统带来复杂性</li>
<li>要考虑的因素</li>
<li>内部碎片</li>
<li>页表长度</li>
<li>辅助储存的物理特性</li>
<li>页面尺寸和缺页率关系</li>
<li>缺页率： 先上升再下降  </li>
</ul>
</li>
</ul>
</li>
<li>程序的编制方法<ul>
<li>页面大小 4K，只有一个页框， 矩阵A[1024][1024] 按行存放</li>
<li>按列访问 和 按行访问 缺页次数： 按列每次修改一位就加载下一个页， 而按行则每次赋值完 </li>
</ul>
</li>
<li>分配给进程的物理页面数：页框越多， 缺页次数越少： 减少速度不断下降（成本越来越高）<ul>
<li>存在平衡点 W</li>
<li>工作集模型   </li>
</ul>
</li>
</ul>
</li>
<li>颠簸（抖动）： 虚存中， 页面在内存与磁盘之间的频繁调度， 使得调度时间比实际运行时间长，导致系统效率下降     </li>
</ul>
<h3 id="工作集模型">工作集模型</h3><ul>
<li>基本思想： 局部性原理， 一般情况下，进程在一段时间内总是集中访问一些页面， 这些页面称为活跃页面， 如果能提供与活跃页面数相等的页框数， 则可减少缺页次数</li>
<li>工作集 W = (t,∆) = 该进程在过去的∆个虚拟时间单位中使用的虚拟页面集合<ul>
<li>工作集内容取决于三个因素<ul>
<li>访问序列特性</li>
<li>当前时刻 t</li>
<li>工作集窗口长度 ∆ </li>
</ul>
</li>
</ul>
</li>
<li>驻留集： 当前时刻进程实际驻留在内存当中的页框集合</li>
<li>两者关系：<ul>
<li>工作集是进程运行过程中固有的性质， 驻留集取决于操作系统分配的页框数和页面置换算法</li>
</ul>
</li>
<li><p>改进：</p>
<ul>
<li>监视每个进程的工作集</li>
<li>周期性地从一个进程的驻留集中移去那些不在它工作集的页面（可以用 LRU 策略）</li>
<li>只有当一个进程的工作集在内存中时， 才可以更好地工作， 即进程的驻留集包括了它的工作集</li>
</ul>
</li>
<li><p>工作集算法：</p>
<ul>
<li>找出一个不在工作集的页面置换</li>
<li>思路<ul>
<li>每个页表项中增加一个字段： 记录该页面最后一次被访问的时间</li>
<li>设置一个时间值 T</li>
<li>判断： 根据一个页面的访问时间是否略在“当前时间 - T”之前或之中决定该页面是否在工作集中         </li>
</ul>
</li>
<li>实现：扫描所有页表项执行操作<ul>
<li>一个页面的 R 为 1， 设置最后访问时间为当前， R 设为 0</li>
<li>如果 R 为 0， 则检查是否不在工作集<ul>
<li>是， 被替换</li>
<li>不是， 记录当前所有扫描的最小值， 继续扫描  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>讨论</p>
<ul>
<li>很多操作系统试图采用工作集算法</li>
<li>其中的一种方法是考虑进程的缺页率并监视来达到类似效果 —— 缺页旅算法</li>
</ul>
</li>
<li><p>页面置换算法小结： 见图</p>
</li>
</ul>
<h2 id="清除策略">清除策略</h2><ul>
<li>分页系统工作的最佳状态： 发生缺页异常时， 系统中有大量的空闲页框</li>
<li>结论： 保存一定数目的页框供给比使用所有内存并在需要时搜索一个页框有更好的性能</li>
</ul>
<h4 id="分页守护进程">分页守护进程</h4><ul>
<li>实现：<ul>
<li>设计一个分页守护进程， 多数时间书面， 定期唤醒检查内存状态</li>
<li>如果空闲页框过少， 分页守护进程通过预设的页面置换算法选择页面换出内存</li>
<li>如果页面装入内存后被修改过， 则将它们写回磁盘</li>
</ul>
</li>
<li>分页守护进程可保证所有的空闲页框都是“干净”的</li>
<li>当一个进程需要使用一个已置换出的页框时， 如果该页框还没有被新的内容覆盖， 则它从空闲页框缓冲池中恢复即可</li>
<li>清楚策略实现<ul>
<li>使用一个双指针时钟， 前指针由分页守护进程控制： 当它指向一个“脏”页面时， 就把该页写回磁盘， 前指针向前， 仅仅向移动指针</li>
<li>后指针用于页面置换， 与标准时钟算法一样</li>
<li>由于分页守护进程的工作， 后指针命中干净页面的概率会增加</li>
</ul>
</li>
</ul>
<h3 id="页缓冲技术">页缓冲技术</h3><ul>
<li>目的： 提高性能</li>
<li>思路：<ul>
<li>不丢弃置换出的页， 将它们放入两个表之一： 如果未被修改， 则放到空闲页链表种， 如果修改了则放到修改页链表</li>
<li>被修改的页以簇的方式写回磁盘（不是一次只写一个， 减少 I/O 操作数量， 减少磁盘访问时间）， 写回后放入空闲页链表</li>
<li>被置换的页仍然保留在内存中， 一旦进程又要访问该页， 可以迅速将它加入该进程的驻留集集合（代价很小）</li>
</ul>
</li>
</ul>
<h2 id="加载控制">加载控制</h2><ul>
<li>系统并发读： 驻留在内存中的进程数目<ul>
<li>通过调节并发进程数进行系统负载控制</li>
</ul>
</li>
<li>解决方案： 进程挂起         </li>
</ul>
<h2 id="其他问题">其他问题</h2><h3 id="内存映射文件">内存映射文件</h3><ul>
<li>基本思想： 进程通过一个系统调用将一个文件映射到虚拟地址空间的一部分， 访问这个文件就象访问内存中的一个大数组而不是对文件读写</li>
<li>在多数实现中， 在映射共享的页面时不会实际读入页面内容， 而是访问时每次一页载入， 磁盘文件则被当作后备存储</li>
<li>当进程退出或显式解除映射时， 修改会写回磁盘</li>
</ul>
<h3 id="策略和机制分离">策略和机制分离</h3><ul>
<li>控制系统复杂度的重要方法： 机制和策略分离</li>
<li>不一定管理全部要在内核</li>
<li>讨论（基于 Mach 微内核操作系统）<ul>
<li>存储管理系统分为三部分<ul>
<li>底层 MMU 处理程序（与机器相关）</li>
<li>做为内核一部分的缺页中断处理程序（与机器无关）</li>
<li>运行在用户空间中的外部页面调度程序（策略）   </li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第十讲_Windows_虚存管理">第十讲 Windows 虚存管理</h1><h2 id="x86">x86</h2><h2 id="Windows_虚存管理">Windows 虚存管理</h2><ul>
<li>内存管理器的组成部分<ul>
<li>一组执行体系服务程序部分</li>
<li>一个页面错误陷阱处理程序</li>
<li>工作集管理器（16）</li>
<li>进程栈交换器（23）</li>
<li>修改页面写出器 （17）</li>
<li>映射页面写出器 （17）</li>
<li>零页线程 （0）</li>
</ul>
</li>
<li>动态产生的内容在需要写回磁盘时，写回到专门的交换空间 （windows 中称为 页面文件page file）</li>
<li><p>windows 无效的 PTE</p>
<ul>
<li>所引用的页面没有被提交（不在内存）</li>
<li>尝试违反权限的页面访问</li>
<li>修改一个共享的写时复制页面</li>
<li>需要扩大栈</li>
<li>所引用的页已被提交但尚未被映射 （清除策略收回了页面， 但页面实际存在） </li>
<li>请求一个零页面 </li>
</ul>
</li>
<li><p>页目录</p>
<ul>
<li>物理地址包存在 KPROCESS</li>
<li>硬件访问页目录， 页表， 页通过 PFN 完成</li>
<li>内核： 通过虚地址来对它们进行访问， 实际上在 x86 还同时映射到0xc0300000</li>
<li>专用寄存器 CR3 用于保存页目录物理地址</li>
</ul>
</li>
<li><p>页目录自映射机制</p>
<ul>
<li>1024 页的页表能表示整个地址空间</li>
<li>那么必定存在一页代表了页目录（两者内容相同）</li>
<li>0xc0300000 前十位和中间十位相同<ul>
<li>PD[0x300] 即自映射目录项</li>
</ul>
</li>
</ul>
</li>
<li><p>windows 的工作集 （windows 中工作集等驾驭驻留集）</p>
<ul>
<li>驻留在物理内存中的虚拟页面的子集</li>
<li>进程工作集： 为每个进程分配的一定数量的页框</li>
<li>系统工作集： 为可分页的系统代码和数据分配页框 </li>
<li>工作集大小动态变化： 开始执行后， 随着访问新页面逐步建立较稳定的工作集</li>
<li>内存访问的局部性区域的位置大致稳定时， 工作集大小页大致稳定</li>
<li>局部性区域的位置改变时， 工作集快速扩张和收缩过度到下一区域</li>
</ul>
</li>
<li><p>页面置换算法</p>
<ul>
<li>基于工作集模型<ul>
<li>由以装入内存的页框组成</li>
<li>最小值（一开始的时候都 load 进来）/最大值 （超过最大时， 如果有空闲还是会分配）</li>
<li>当可用页框数量数量降低到一定程度时， 启动工作集修正策略</li>
</ul>
</li>
<li>平衡集管理器线程（调度算法中提到过， 每秒醒来一次） 调用 工作集管理器<ul>
<li>周期性检查： 大量可用内存， 内存开始紧张， 内存紧缺</li>
</ul>
</li>
</ul>
</li>
<li><p>用户空间内存分配方式</p>
<ul>
<li>以页为单位的虚拟内存分配方式（Virtualxxx）<ul>
<li>进程地址空间 0～0x7fffffff ， 用户必须经过保留和提交两个阶段</li>
<li>windows 中用 VAD 来解决判断保留页面的问题 </li>
<li>每一个进程， 内存管理器维护一组虚拟地址描述符（VAD）来描述一段被分配的进程虚拟空间的状态（结构： 平衡二叉树）</li>
</ul>
</li>
<li>内存映射文件 （CreateFileMapping， MapViewOfFile）<ul>
<li>windows 中使用区域对象（底层）， 开放的接口：文件映射对象</li>
<li>为大数据流和文件共享服务</li>
<li>两个进程对同一个区域对象建立视图时， 发生了区域共享 </li>
<li>对区域读写与读写数组一样</li>
</ul>
</li>
<li>内存堆方法（Heapxxx 和早起的借口 Loaclxxx 和 Globalxxxx）<ul>
<li>适合大量小内存申请</li>
</ul>
</li>
</ul>
</li>
<li><p>物理内存管理</p>
<ul>
<li>页框号数据库 （PFN数据库）</li>
<li>结构 MMPFN（24字节）： 保存每一个物理页的相关信息<ul>
<li>页框的状态<ul>
<li>活动（Active） / 有效（Valid）： 在工作集中</li>
<li>过度（Transition）： 系统正在从一个文件将内容读入该页框，或者写出该页内容</li>
<li>空闲（Free）</li>
<li>零初始化（zeroed） 空闲且为 0</li>
<li>坏（Bad） 该页框存在硬件错误，不能被使用</li>
<li>后备（standby）：</li>
<li>曾经在某个进程工作集里， 且该页框的内容还没有改变 </li>
<li>但该页框已经被移出工作集， 只是 PTE 被标记为 invalid 和 transition（两位表示 standby） </li>
<li>当此进程需要再次访问这一页，直接把该页框从 stanby 变为 active（valid）</li>
<li>修改（modify）：</li>
<li>有修改的 standby</li>
<li>在被其他进程使用之前写回   </li>
</ul>
</li>
</ul>
</li>
<li>全局变量 MmPfnDatabase 保存页框号数据库的首地址</li>
</ul>
</li>
<li><p>支持写时复制技术</p>
</li>
</ul>
<h1 id="第十一讲_文件系统">第十一讲 文件系统</h1><h2 id="文件系统的基本概念">文件系统的基本概念</h2><ul>
<li>文件是对磁盘的抽象</li>
<li>所谓文件是指一组带标识（即文件名）的，在逻辑上有完整意义的信息项序列</li>
<li>信息项： 构成文件内容的基本单位（单个/多个字节）， 各信息项之间具有顺序关系</li>
<li><p>谁建立/谁使用 谁解释</p>
</li>
<li><p>文件系统：操作系统中统一管理信息资源的子系统， 管理文件的存储，检索，更新，提供安全可靠的共享和保护手段， 并且方便用户使用</p>
<ul>
<li>统一管理磁盘空间， 实施磁盘空间的分配和回收</li>
<li>实现文件的按名存取（名字空间映射磁盘空间）</li>
<li>实现文件信息的共享， 提供数据可靠性和安全保障</li>
<li>向用户提供一个方便使用，维护的接口， 并向用户提供相关信息</li>
<li>提高文件系统性能</li>
<li>I/O 接口相关</li>
</ul>
</li>
<li><p>文件的分类</p>
<ul>
<li>普通文件</li>
<li>目录文件： 管理文件系统的系统文件</li>
<li>特殊文件</li>
</ul>
</li>
<li><p>文件的逻辑结构</p>
<ul>
<li>文件内部结构： 从用户角度看文件， 由用户的访问方式确定</li>
<li>流式文件 /  记录式文件 （操作系统角度）</li>
<li>堆结构 / 顺序结构 / 索引结构 （数据库管理系统角度）</li>
</ul>
</li>
<li><p>文件的存取方式</p>
<ul>
<li>顺序存去 </li>
<li>随机存取 </li>
</ul>
</li>
<li>存储介质与物理块<ul>
<li>磁盘 / SSD / 磁带 / …..</li>
<li>物理块<ul>
<li>存储设备划分为大小相等的块， 统一编号</li>
<li>以块为单位进行信息的存储、 传输、 分配   </li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘结构 </p>
<ul>
<li>扇区： 标题、 数据、 ECC 纠错信息</li>
<li>三个动作：<ul>
<li>寻道</li>
<li>旋转延迟</li>
<li>数据传输</li>
</ul>
</li>
</ul>
</li>
<li><p>文件属性</p>
<ul>
<li>文件控制块（或元数据）FCB： 操作系统为管理文件而设置的数据结构， 存放了为管理文件所需的所有有关信息 </li>
<li>常用属性： 文件名、文件号、保护、口令….</li>
</ul>
</li>
<li><p>文件操作</p>
<ul>
<li>create / delete / open / close</li>
</ul>
</li>
<li><p>文件目录</p>
<ul>
<li>统一管理每个文件信息</li>
<li>将左右文件的管理信息阻止在一起， 即构成文件目录</li>
<li>目录项<ul>
<li>构成文件目录的基本单元</li>
<li>目录项<strong>可以</strong>是FCB， 目录是文件控制块的有序集合</li>
</ul>
</li>
<li>目录文件（记录式）<ul>
<li>将文件目录以文件的形式存放在磁盘上</li>
<li>一种特殊类型的文件， 其内容由目录项组成</li>
</ul>
</li>
<li>只允许内核修改目录， 应用程序通过系统调用访问目录</li>
<li>树形结构目录              </li>
</ul>
</li>
</ul>
<h2 id="文件系统布局">文件系统布局</h2><h3 id="概述">概述</h3><ul>
<li>实现文件系统需要考虑： 磁盘与内存中的内存布局<ul>
<li>磁盘上<ul>
<li>如何启动所存储的操作系统</li>
<li>磁盘是怎样管理的？ 即怎样获取磁盘的有关信息？</li>
<li>目录文件在磁盘上存放？ 普通文件在磁盘上怎么存放</li>
</ul>
</li>
<li>内存中</li>
</ul>
</li>
<li>磁盘分区： 把一个物理磁盘的存储空间划分为几个相互独立的部分， 称为分区</li>
<li><p>文件卷： 逻辑分区， 由一个或多个物理块组成</p>
<ul>
<li>一个文件卷可以是整个磁盘或部分磁盘或跨盘（RAID）</li>
<li>同一个文件卷中使用同一份管理数据进行文件分配和磁盘空闲空间管理， 不同的文件卷中的管理数据是独立的</li>
<li>一个文件卷上: 包括文件系统信息、一组文件（用户、目录）、未分配空间</li>
<li>物理块/块/蔟： 一个或多个（2的幂）连续的扇区， <strong>可寻址数据块</strong></li>
<li>格式化：在一个文件卷上建立文件系统的过程</li>
</ul>
</li>
<li><p>磁盘上的内容</p>
<ul>
<li>引导区： 通常为第一个， 从改卷引导操作系统所需信息， 每个卷一个</li>
<li>卷（分区）信息</li>
<li>目录结构（目录文件）</li>
<li>用户文件</li>
</ul>
</li>
</ul>
<h3 id="磁盘上文件系统的布局">磁盘上文件系统的布局</h3><ul>
<li>UNIX<ul>
<li>主引导记录 — 分区表 — 分区1 - 分区2….</li>
<li>每个分区结构 <br> 引导记录 - 超级数据块（管理数据） - 空闲区管理 - I-节点区 - 根目录区 - 文件和目录区</li>
</ul>
</li>
<li>WINDOWS <ul>
<li>FAT 文件系统<ul>
<li>引导区 - 文件分配表1 - 文件分配表2（与1一摸一样） - 根目录 - 其他目录和文件 </li>
</ul>
</li>
<li>NTFS 卷<ul>
<li>引导区 - 主控文件表 - 系统文件 - 文件存储区 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件的物理结构">文件的物理结构</h3><ul>
<li>文件在物理介质上的存放方式， 也是系统分配给文件的物理块的位置和顺序</li>
<li>要考虑的问题：<ul>
<li>存储效率： 外部碎片等</li>
<li>读写性能： 访问速度</li>
</ul>
</li>
<li>连续结构（顺序）： 文件的信息是存放在若干连续块<ul>
<li>优点<ul>
<li>简单、高效</li>
<li>支持顺序存取和随机存取</li>
<li>所需的磁盘寻到次数和寻到时间最少</li>
<li>可以同时读多个块， 检索一个块容易</li>
</ul>
</li>
<li>缺点<ul>
<li>文件不能动态增长： <ul>
<li>预留空间：浪费或重新分配和移动</li>
</ul>
</li>
<li>不利于文件内容的插入和删除</li>
<li>外部碎片问题： 存储紧缩技术</li>
</ul>
</li>
</ul>
</li>
<li>链接结构： 一个文件的信息存放在若干不连续的物理块中， 各块之间通过指针连接<ul>
<li>FCB 只需要记录首块指针</li>
<li>优点<ul>
<li>提高磁盘空间利用率， 不存在外部碎片</li>
<li>忧虑与文件的内容插入和删除</li>
<li>有利于文件动态扩充</li>
</ul>
</li>
<li>缺点<ul>
<li>指针占一些空间， 数据不是整数次幂</li>
<li>可靠性问题： 链接指针出错</li>
<li>更多的寻到次数和时间</li>
<li>存取慢， 不支持随机存取</li>
</ul>
</li>
<li>变形： FAT 结构， 把所有指针放在一起而不是放在各块<ul>
<li>windows 中 FCB = 目录项， 包含起始蔟号</li>
<li>表项由三种值： 0（没分出去）， 下一块号， -1（结束）</li>
<li>FAT 表所有文件共享一张<ul>
<li>FCB -&gt; FAT表中某项 -&gt; …. -&gt; -1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>索引结构： 系统为每个文件简历一个专用数据结构——索引表， 并将这些块的块号存在一个索引表中， 一个索引表就是磁盘块地址数组， 其中第 i 个条目指向文件的第 i 块</p>
<ul>
<li>问题： 索引表很大， 需要多个物理块存放时怎么办</li>
<li>索引表组织：<ul>
<li>链接方式： 一个盘块存一个索引表， 多个索引表</li>
<li>多级索引</li>
<li>综合（UNIX） （UNIX FCB = 目录项 + I-节点）<ul>
<li>每个文件的索引表 15 个索引项， 每项 2 字节</li>
<li>最前面 12 项直接存放文件信息的物理块号（直接寻址）</li>
<li>第 13 项指向一个物理块， 该块中最多可以存放 256 个文件物理块的块号（一级索引表）</li>
<li>对于更大的文件， 还可以利用第14和第15项作为二级和三级索引表 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>目录文件： 文件目录在磁盘上的存储方式（操作系统使用）</p>
<ul>
<li>windows 目录项 = FCB</li>
<li>组织方式：<ul>
<li>顺序</li>
<li>散列表（hash）</li>
<li>B 树/B+ 树 （NTFS系统使用）</li>
</ul>
</li>
</ul>
</li>
<li>文件目录检索<ul>
<li>文件名 -&gt; 文件目录 -&gt; 磁盘</li>
<li>访问一个文件两个步骤</li>
<li>步骤1: <ul>
<li>目录检索 —— 文件名 -&gt; FCB</li>
<li>文件名解析： 把逻辑名字转化为物理资源</li>
</ul>
</li>
<li>步骤2: 文件寻址</li>
</ul>
</li>
<li>目录文件的改进： 加快目录检索<ul>
<li>一种解决方案<ul>
<li>FCB 分成两部分<ul>
<li>符号目录项： 文件名、文件号</li>
<li>基本目录项： 文件名以外的字段</li>
</ul>
</li>
<li>例子： UNIX 的 I节点</li>
</ul>
</li>
</ul>
</li>
<li>UNIX 文件系统<ul>
<li>FCB = 目录项 + I 节点</li>
<li>目录项： 文件名 + I 节点好</li>
<li>目录文件由目录项构成</li>
<li>I 节点： 描述文件的相关信息</li>
<li>每个文件由一个目录项、一个I节点和若干磁盘快构成 </li>
</ul>
</li>
<li>Windows —— FAT16 文件系统 （16 表示 FAT 表项大小）<ul>
<li>FAT16 <ul>
<li>蔟： 1、2、4、8、16、32 或 64 扇区</li>
<li>文件系统的数据记录在“引导扇区”中</li>
<li>文件分配表 FAT 的作用： 描述蔟的分配状态、 标注下一簇的蔟号</li>
<li>FAT 表项： 2字节（16位）</li>
<li>目录项： 32 字节</li>
<li>根目录大小固定</li>
</ul>
</li>
<li>引导区             <ul>
<li>MBR 主引导扇区 —— 0号扇区</li>
<li>DBR 一般引导扇区</li>
<li>MBR / DBR 结束标志 0x55AA， 开头为跳转到引导代码</li>
</ul>
</li>
<li>文件分配表 FAT<ul>
<li>可以看成一个整数数组， 每个证书代表数据去的一个蔟号</li>
<li>状态： 未使用、坏蔟、系统保留、被文件占用（下一簇号）….</li>
</ul>
</li>
</ul>
</li>
<li><p>FAT32</p>
<ul>
<li>根目录不固定大小</li>
<li>目录项仍然 32 字节， 但有不同类型： “.“目录项， ”..“目录项、 短文件名目录项、 长文件名目录项</li>
<li>支持长文件名格式，支持 Unicode，无法支持高级容错特性</li>
<li>一个文件至少对应两个目录项（名字越长占用越多）                 </li>
</ul>
</li>
<li><p>空闲块管理</p>
<ul>
<li>位图</li>
<li>空闲块表</li>
<li>空闲块链表<ul>
<li>成组链接法</li>
<li>每组第一块不空， 用来放下一组的空闲块块号</li>
<li>专用块记录空闲磁盘块的第一组空闲块的块号</li>
<li>专用块放在空闲管理区</li>
<li>第一组的第一块分出去之前要复制到专用块里</li>
<li>倒数第二组的索引最多 99 个， 因为最后一组没有管理块</li>
</ul>
</li>
</ul>
</li>
<li><p>运行时文件结构 UNIX</p>
<ul>
<li>系统打开文件表<ul>
<li>整个系统一张</li>
<li>放在内存： 用于保存已打开文件的 FCB</li>
<li>FCB + 引用计数 + 修改标志</li>
</ul>
</li>
<li>用户打开文件表<ul>
<li>每个进程一个</li>
<li>维护打开文件的状态和信息</li>
<li>进程的PCB中记录了用户打开文件表的位置   </li>
<li>文件描述符+打开方式+读写指针+系统打开文件表入口</li>
</ul>
</li>
</ul>
</li>
<li><p>文件操作的实现</p>
<ul>
<li>创建文件：使之时创建文件的 FCB<ul>
<li>分配足够的存储空间</li>
<li>在目录中为新文件建立一个目录项， 根据提供的参数及需要填写有关内容</li>
<li>目的： 建立系统与文件的联系</li>
</ul>
</li>
<li>打开文件：<ul>
<li>根据文件名在文件目录中检索， 并将该文件的目录项读如内存， 建立相应的数据结构， 为后续的文件操作做好准备</li>
<li>返回文件描述符 / 文件句柄</li>
</ul>
</li>
</ul>
</li>
<li><p>文件共享： 一个文件被多个用户或进程使用</p>
<ul>
<li>目的： 节省时间和存储空间 / 交换信息</li>
<li>一种实现 —— 文件别名<ul>
<li>硬链接： 利用多个路径名描述统一共享文件， 多个目录项只想一个文件<ul>
<li>Link 命令： 在用户自己的目录中对要共享的文件建立起相应的表目， 即建立两个文件的等价关系</li>
<li>Linux 例子：</li>
<li>多个文件名的目录项指向同一个 i 节点</li>
<li>i 节点中增加引用计数字段   </li>
</ul>
</li>
<li>软链接（符号链接/快捷方式）： 建立一种特殊类型的文件， 通过文件内容与另一个文件建立链接              <ul>
<li>建立一种特殊类型的文件</li>
<li>只有真正的文件所有者才有指向 i 节点的指针</li>
<li>系统开销大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>挂在和卸载<ul>
<li>将一个文件系统加入到另一个文件系统</li>
<li>用户提供： 被挂在的文件系统的根目录/挂载点</li>
</ul>
</li>
</ul>
<h1 id="第十二讲_文件系统的管理">第十二讲    文件系统的管理</h1><h2 id="文件系统的管理">文件系统的管理</h2><ul>
<li>文件系统的可靠性<ul>
<li>可靠性： 抵御和预防各种物理性破坏和人为破坏的能力 </li>
<li>坏块问题： 禁止使用</li>
<li>备份： 通过转储操作， 形成文件或文件系统的多个副本<ul>
<li>全量转储： 定期将所有文件拷贝到后援处理器</li>
<li>增量转储： 只转储修改的文件， 即两次本分之间的修改， 减少系统开销</li>
<li>物理转储： 从磁盘第 0 块开始， 将所有磁盘块按序列输出到磁带</li>
<li>逻辑转储： 从一个或几个指定目录开始， 递归地转储自给定日期后所有更改的文件或目录</li>
</ul>
</li>
</ul>
</li>
<li>文件系统的一致性（源数据的一致性）<ul>
<li>问题的产生： 磁盘块 -&gt; 内存 -&gt; 写回磁盘块， 写回之前系统崩溃， 则文件系统出现不一致           -    解决方案： 设计一个实用程序， 当系统再次启动时， 运行该程序， 检查磁盘块和目录<ul>
<li>UNIX 检查过程： 两张表， 每块对应表中一个计数器， 初值为 0<ul>
<li>表1记录每块在文件中出现的次数</li>
<li>表2记录每块在空闲块表中的出现次数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>文件系统写入方式<ul>
<li>考虑文件系统一致性和性能</li>
<li>通写<ul>
<li>内存中的修改立即写到磁盘</li>
<li>缺点：性能差</li>
<li>例： FAT 文件系统</li>
</ul>
</li>
<li>延迟写（lazy-write）<ul>
<li>利用回写缓存的方法得到高速</li>
<li>可恢复性差</li>
</ul>
</li>
<li>可恢复写<ul>
<li>采用事务日志来实现文件系统的写入</li>
<li>既考虑安全性， 又考虑速度性能</li>
<li>例： NTFS</li>
</ul>
</li>
</ul>
</li>
<li>文件系统的安全性<ul>
<li>安全性： 确保未经授权的用户不能存取某些文件</li>
<li>数据丢失 -&gt; 备份解决</li>
<li>入侵者</li>
<li>文件保护机制<ul>
<li>文件保护： 用于提供安全性、特定的操作系统机制<ul>
<li>对拥有权限的用户， 应该让其进行相应操作， 否则应该禁止</li>
<li>放置其他用户冒充对文件进行操作</li>
</ul>
</li>
<li>用户身份验证<ul>
<li>用户登录时， 检验其身份（用户是谁，用户拥有什么，用户知道什么）</li>
<li>口令</li>
<li>物理坚定： 磁卡、指纹、签名分析、手指长度分析</li>
</ul>
</li>
<li>访问控制<ul>
<li>主动控制： 访问控制表</li>
<li>每个文件一个，放在内核空间</li>
<li>记录用户 ID 和访问权限 </li>
<li>用户可以是组， 文件也可以是组 </li>
<li>能力表         </li>
<li>每个用户一个， 放在内核空间</li>
<li>记录用户可以访问的权限</li>
</ul>
</li>
</ul>
</li>
<li>UNIX 的文件保护</li>
<li>数据恢复技术<ul>
<li>数据恢复的原理： 数据未被真正破坏， 只是组织形式被破坏， 操作系统或用户不能访问 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统的性能">文件系统的性能</h2><ul>
<li>提高文件系统性能的方法： 目录项（FCB）分解、当前目、磁盘碎片整理、磁盘（块）高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、RAID技术</li>
</ul>
<h3 id="磁盘高速缓存">磁盘高速缓存</h3><ul>
<li>内存中为磁盘块设置的一个缓冲区， 保存了磁盘中某些块的副本</li>
<li>当出现一个对某一特定块的 I/O 请求时， 首先检测以确定改块是否在磁盘高速缓存中</li>
<li>如果在直接读写； 否则加载到高速缓存， 再拷贝到需要的地方</li>
<li>利用局部性原理</li>
<li>有些系统成为 文件缓存、块高速缓存、缓冲区高速缓存</li>
<li>块高速缓存的组织、置换、一致性                        <ul>
<li>hash 表（检索块） + 链表（计算 LRU）</li>
</ul>
</li>
</ul>
<h3 id="提前读取">提前读取</h3><ul>
<li>思路： 每次访问磁盘， 多读入一些磁盘块</li>
<li>依据： 空间局部性</li>
<li>开销： 较小（只有数据传输时间）</li>
<li>具有针对性</li>
</ul>
<h4 id="windows_的文件访问方式">windows 的文件访问方式</h4><ul>
<li>不使用文件缓冲<ul>
<li>普通方式</li>
</ul>
</li>
<li>使用文件缓冲<ul>
<li>预读取， 每次读取的块大小、缓冲区大小、置换方式</li>
<li>写回。 写回时时机选择， 已知性问题。</li>
</ul>
</li>
<li><p>异步模式</p>
<ul>
<li>不再等待磁盘操作完成</li>
<li>使处理器和 I/O 并发工作   </li>
</ul>
</li>
<li><p>cache manager 实现对缓存的控制 （使用文件缓冲）</p>
<ul>
<li>读取数据的时候预取</li>
<li>定时保护一致性</li>
</ul>
</li>
</ul>
<h3 id="合理分配磁盘空间">合理分配磁盘空间</h3><ul>
<li>分配块时， 把有可能顺序存取的块放在一起<ul>
<li>尽量分配在同一柱面上， 减少磁盘臂的移动 </li>
</ul>
</li>
</ul>
<h3 id="磁盘调度">磁盘调度</h3><ul>
<li>当多个访盘请求在等待时， 采用一定的策略， 对这些请求的服务顺序调整安排</li>
<li>降低平均磁盘服务时间， 达到公平、高效</li>
<li>公平： 一个 I/O 请求在有限时间内满足</li>
<li><p>高效：减少设备机械运动带来的时间浪费</p>
<ul>
<li>减少寻道时间</li>
<li>减少延迟时间</li>
</ul>
</li>
<li><p>先来先服务：</p>
<ul>
<li>优点： 简单、 公平</li>
<li>缺点： 效率不高， 相邻两次请求可能会造成最内到最外的柱面寻道， 使磁头反复移动， 增加了服务时间， 对机械也不利</li>
</ul>
</li>
<li>最短寻道时间有限： 优先选择距当前次头最近的访问请求进行服务， 主要考虑寻道优先<ul>
<li>优点： 改善平均服务时间</li>
<li>缺点： 不公平， 饥饿</li>
</ul>
</li>
<li><p>扫描算法/电梯算法</p>
<ul>
<li>当设备无访问请求， 不动</li>
<li>有访问请求， 按一个方向移动， 在移动过程中对遇到的请求进行服务， 然后判断该方向上是否还有访问请求， 如果有则继续扫描； 否则改变移动方向， 并为经过的请求服务， 如此反复</li>
</ul>
</li>
<li><p>单向扫描调度算法</p>
<ul>
<li>总是从 0 号柱面开始向里扫描</li>
<li>按照各自要访问的柱面位置的次序去选择访问者</li>
<li>移动臂到达最后一个柱面后， 快速返回 0 柱面</li>
<li>返回时不进行服务</li>
</ul>
</li>
<li><p>N-step-scan</p>
<ul>
<li>把磁盘请求队列分成长度为 N 的子队列， 每一次用 SCAN 处理一个子队列</li>
<li>在处理某一队列时， 新请求必须添加在….</li>
</ul>
</li>
<li><p>FSCAN</p>
<ul>
<li>两个队列， 开始时都在一个队列， 新请求在另一个队列， 然后交换</li>
</ul>
</li>
<li><p>旋转调度算法： 根据延迟时间来决定执行次序的调度</p>
<ul>
<li>分析：<ul>
<li>若干等待访问者请求访问同一磁头的不同扇区</li>
<li>若干等待访问者请求访问不同磁头的不同编号的扇区</li>
<li>若干等待访问者请求访问不同磁头上具有相同的扇区</li>
</ul>
</li>
<li>解决方案<ul>
<li>对于前两种情况： 总是让首先到达读写磁头位置下的扇区先进行传送操作</li>
<li>对于第三种情况： 这些扇区同时到达读写磁头位置下， 可任意选择一个磁头读写或传送</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="信息的优化分布">信息的优化分布</h3><ul>
<li>记录在磁道上的排列方式也会影响输入输出操作的时间</li>
</ul>
<h3 id="记录的成组与分解">记录的成组与分解</h3><ul>
<li>记录的成组： 把若干个逻辑记录合成一组存放一块的工作</li>
<li>进行成组操作时必须使用内存缓冲区， 缓冲区的长度等于逻辑记录长度乘以成组的块因子</li>
<li>目的： 提高了存储空间的利用率；减少了启动外设的次数， 提高系统的工作效率</li>
<li>记录的分解： 从一组逻辑记录中吧一个逻辑记录分离出来的操作</li>
</ul>
<h3 id="RAID_技术">RAID 技术</h3><ul>
<li>设计时要考虑的是： 磁盘存储系统的 速度、容量、容错、数据灾难后的数据恢复</li>
<li>解决方案： RAID （独立磁盘冗余阵列）<ul>
<li>多块磁盘按照一定要求构成， 操作系统则将它们看成一个独立的存储设备</li>
</ul>
</li>
<li>目标： 提高可靠性和性能</li>
<li>把多个磁盘（物理）组织在一起， 作为一个逻辑卷提供磁盘跨越功能</li>
<li>数据组织：<ul>
<li>通过把数据分成多个数据块， 并行读出/写入多个磁盘， 提高传输率（条带化 strip）</li>
<li>通过镜像或校验操作， 提供容错能力（冗余）</li>
</ul>
</li>
<li>最简单的 RAID： 镜像 / 最复杂的 RAID： 块交错校验</li>
</ul>
<h4 id="RAID_0_-_条带化">RAID 0 - 条带化</h4><ul>
<li>数据分布在阵列的所有磁盘上</li>
<li>有数据请求时， 同时多个磁盘并行操作</li>
<li>充分利用总线带宽， 数据吞吐率提高，驱动器负载平衡</li>
</ul>
<h4 id="RAID_1_-_镜像">RAID 1 - 镜像</h4><ul>
<li>最大限度保证数据安全及可恢复行</li>
<li>所有数据同时存在两快盘的相同位置</li>
<li>利用率 50%</li>
</ul>
<h4 id="RAID_2_并行访问_-_海明码校验">RAID 2 并行访问 - 海明码校验</h4><ul>
<li>专门盘放校验码 （条为单位）</li>
</ul>
<h4 id="RAID_3_-_叫错位奇偶校验">RAID 3 - 叫错位奇偶校验</h4><ul>
<li>以字节单位将数据拆分， 交叉写入</li>
<li>专门放置一个存储校验盘， 保存奇偶校验</li>
</ul>
<h4 id="RAID_4_-_交错块奇偶校验">RAID 4 - 交错块奇偶校验</h4><ul>
<li>和 RAID 3 类似， 块为单位</li>
</ul>
<h4 id="RAID_5_-_交错块分布式奇偶校验">RAID 5 - 交错块分布式奇偶校验</h4><ul>
<li>奇偶校验分散在各个磁盘（分布式）</li>
<li>数据读出效率高， 写入效率一般</li>
<li>磁盘利用率好</li>
</ul>
<h4 id="RAID_6_交错块双重分布式校验">RAID 6 交错块双重分布式校验</h4><ul>
<li>参考 4 ，5</li>
</ul>
<h4 id="RAID_7_最优化异步高_I/O_速率及高数据传输率">RAID 7 最优化异步高 I/O 速率及高数据传输率</h4><ul>
<li>有一个操作系统独立主机运行  </li>
</ul>
<h2 id="文件系统的结构设计">文件系统的结构设计</h2><ul>
<li>文件系统分类<ul>
<li>磁盘文件系统</li>
<li>数据库文件系统</li>
<li>日志文件系统</li>
<li>网络/分布式文件系统</li>
<li>虚拟文件系统               </li>
</ul>
</li>
<li>如何定义对用户接口<ul>
<li>文件及属性、文件操作、目录结构</li>
</ul>
</li>
<li>如何将逻辑文件系统映射到物理磁盘设备<ul>
<li>数据结构及算法</li>
</ul>
</li>
<li><p>文件系统实现时如何分层  </p>
</li>
<li><p>虚拟文件系统： 对多个不同文件系统的抽象</p>
<ul>
<li>功能：<ul>
<li>提供相同的文件和文件系统接口</li>
<li>管理所有文件和文件系统关联的数据结构</li>
<li>高效查询历程， 遍历文件系统</li>
<li>与特定文件系统模块的交互</li>
</ul>
</li>
</ul>
</li>
<li><p>日志结构文件系统</p>
<ul>
<li>LFS Log-structured File System</li>
<li>思路： 提高磁盘写操作的效率 -&gt; 避免寻找写的位置</li>
<li>典型写操作： 改变 文件目录i节点、目录项、文件i节点、文件本身</li>
<li>把整个磁盘看作是一个日志， 每次写到其末尾。 集中（按一段）写入日志末尾， 将 i 节点和文件内容一起写入， 建立子 i 节点表</li>
<li>清理线程： 扫描日志， 清理， 生成新的段 </li>
</ul>
</li>
<li><p>日志文件系统</p>
<ul>
<li>借鉴日志文件结构文件系统设计思路： 鲁棒性</li>
<li>保存一个日志： 记录系统下一步要做什么</li>
<li>系统出错后， 恢复时查看日志， 完成所作操作</li>
<li>windows 的 NTFS， Linux 的 ext3、 ReiserFS </li>
<li>步骤： 例如删除一个文件<ul>
<li>操作：<ul>
<li>目录中删除</li>
<li>释放 i 节点</li>
<li>磁盘块归还到空闲</li>
</ul>
</li>
<li>实际操作：<ul>
<li>写日志项（3个操作）</li>
<li>日志项写入磁盘</li>
<li>执行操作</li>
<li>擦除日志项（做一个操作擦一个）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Windows_文件系统模型">Windows 文件系统模型</h2><h3 id="NTFS_文件系统">NTFS 文件系统</h3><ul>
<li>基于原子事务概念</li>
<li>NTFS 对关键文件系统信息采用冗余存储</li>
<li>NTFS 提供了综合的安全模型， 支持加密文件系统</li>
<li>NTFS 多级目录结构， 支持别名</li>
<li>NTFS 文件由多个文件属性构成， 每个属性由属性名和属性流（属性值）组成    -    如： 文件内容 （data， ….） data 为属性名</li>
<li>NTFS 的磁盘结构<ul>
<li>卷<ul>
<li>可以一盘多卷， 可以一卷多盘</li>
</ul>
</li>
<li>蔟<ul>
<li>逻辑蔟号 LCN： 整个卷中的蔟号</li>
<li>虚拟蔟号 VCN： 文件内部的蔟从头到尾编号</li>
</ul>
</li>
</ul>
</li>
<li>文件名/目录名： 最多255字节， 可以包含 unicode<ul>
<li>每个文件有一个 64位的， 称为引用号的唯一标示</li>
<li>文件引用号的组成<ul>
<li>文件号（48位， 该文件在 MFT（主控文件表）中的位置）</li>
<li>文件顺序号</li>
</ul>
</li>
</ul>
</li>
<li>主控文件表 MFT （类似 i 节点）<ul>
<li>每个记录对应一个文件或目录</li>
<li>自身也是一个文件</li>
<li>每个文件/目录至少有一个 MFT</li>
<li>一般： 每个 MFT 的前几十个字节有固定头结构， 用以描述本 MFT 项的属性（如是否占用等）； 之后的字节用于存放属性；其余信息可以放到卷中其他可用蔟中</li>
<li>访问文件： 先找 MFT 项， 再根据其中信息找到文件内容</li>
</ul>
</li>
<li>NTFS 对属性提供各种操作<ul>
<li>读写都是针对属性</li>
<li>常驻属性与非常驻属性<ul>
<li>标准信息、文件名、索引根是常驻属性（常驻在 MFT）</li>
<li>延展或延伸： MFT 之外的区域， 可存放变长的非常驻属性    </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式文件系统">分布式文件系统</h2><ul>
<li>分布式计算机系统<ul>
<li>强调资源、 任务、 功能和控制的全面分布</li>
</ul>
</li>
<li>工作方式<ul>
<li>任务分布</li>
<li>功能分布</li>
</ul>
</li>
<li>分布式文件系统<ul>
<li>完成的功能类似于传统操作系统中的文件系统， 永久性存储和共享文件， 允许用户直接存取远程文件而不需要将它们复制到本地</li>
</ul>
</li>
<li>HDFS<ul>
<li>分布式，  部署在低廉设备上</li>
<li>高容错、高吞吐、适合大数据集</li>
<li>块存储<ul>
<li>默认一块 64M</li>
<li>如果文件大小小于数据块， 也不独占</li>
<li>为什么用块存储： 减少寻址规模</li>
</ul>
</li>
<li>流式读写<ul>
<li>校验和检验</li>
<li>只支持在文件末尾添加数据</li>
<li>不支持在任意位置修改</li>
<li>并发读</li>
<li>不并发写</li>
</ul>
</li>
<li>数据冗余         </li>
</ul>
</li>
</ul>
<h1 id="第十三讲_I/O_系统">第十三讲 I/O 系统</h1><ul>
<li>I/O 的特点<ul>
<li>I/O 性能经常是系统性能的瓶颈</li>
<li>操作系统庞大复杂的原因之一<ul>
<li>资源多、杂， 并发均来自 I/O（不同 I/O 各种属性例如速度，数据表示， 传送单位不同） </li>
<li>与其他功能联系密切， 特别是文件系统</li>
</ul>
</li>
</ul>
</li>
<li>CPU 与 设备的连接<ul>
<li>设备控制器<ul>
<li>CPU 和 I/O 设备的接口           </li>
<li>特殊寄存器</li>
</ul>
</li>
</ul>
</li>
<li>设备分配——按数据特征分<ul>
<li>字符设备<ul>
<li>字节为单位， 传输速率低， 不可寻址（键盘、 鼠标）</li>
<li>I/O 命令： get(); put(); 通常使用文件接口和语义 </li>
</ul>
</li>
<li>块设备<ul>
<li>以数据块为单位， 传输速率较高， 可寻址（随机读写）（磁盘）</li>
<li>I/O 命令： 原始 I/O 或文件系统接口； 内存映射文件访问  </li>
</ul>
</li>
<li>网络设备<ul>
<li>格式化报文交换（以太网、蓝牙）</li>
<li>I/O 命令： send/receive 网络报文； 通过网络接口支持多种网络协议</li>
</ul>
</li>
</ul>
</li>
<li>设备的分类 —— 从资源分配角度<ul>
<li>独占设备： 一段时间一个进程使用， 一般为低速设备（打印机）</li>
<li>共享设备： 多个进程交叉使用， 效率高（磁盘）</li>
<li>虚设备： 在一类设备上模拟另一类： 如用共享设备模拟独占设备， 被模拟的称为虚设备</li>
</ul>
</li>
<li>I/O 管理<ul>
<li>应用程序/文件管理 -&gt; I/O 设备管理 -&gt; 设备控制器中的特殊寄存器</li>
<li>设备管理器： 逻辑I/O（设备无关） + 设备驱动程序 + 中断服务程序</li>
</ul>
</li>
<li>I/O 管理的目标和任务<ul>
<li>完成用户的请求， 控制设备的各种操作， 完成 I/O 设备与内存之间的数据交换， 最终完成用户的I/O请求<ul>
<li>设备分配与回收<ul>
<li>记录设备的状态</li>
<li>根据用户的请求和设备的类型（可能独占， 需要分配给对应进程）， 采用一定的分配算法， 选择一条数据通路</li>
</ul>
</li>
<li>执行设备驱动程序， 实现真正的I/O操作</li>
<li>设备终端处理： 处理外部设备的中断</li>
<li>缓冲区管理： 管理 I/O 缓冲区</li>
</ul>
</li>
<li>建立方便、同意的独立于设备的接口<ul>
<li>方便性： 向用户提供使用外部设备的方便接口， 使用户使用时不考虑设备的复杂物理特性</li>
<li>统一性： 对不同的设备采取统一的操作方式， 在用户程序中使用的是逻辑设备</li>
<li>逻辑设备与物理设备、屏蔽硬件细节</li>
</ul>
</li>
<li>充分利用各种技术（通道、中断、缓冲、异步I/O等）提高CPU与设备、设备与设备之间的并行工作能力， 充分利用资源， 提高资源利用率<ul>
<li>并行性</li>
<li>均衡性（使设备充分忙碌）</li>
</ul>
</li>
<li>保护<ul>
<li>设备传送或管理的数据应该是安全的、不被破坏的、保密的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="I/O_硬件组成">I/O 硬件组成</h2><ul>
<li>一般由机械和电子两部分组成<ul>
<li>机械部分是设备本身（物理装置）</li>
<li>电子部分又称为设备控制器（或适配器）<ul>
<li>（端口）地址译码</li>
<li>按照主机与设备之间约定的格式和过程接受计算机发来的数据和控制信号 或 向主机发送数据和状态信号</li>
<li>将计算机的数字信号转换成机械部分能识别的模拟信号 或 反之</li>
<li>实现设备内部硬件缓冲、 数据加工等提高性能或增强功能</li>
</ul>
</li>
</ul>
</li>
<li>控制器的作用<ul>
<li>操作系统将命令写入控制器的接口寄存器/缓冲区， 以实现输入/输出， 并从借口寄存器读取状态信息或结果信息</li>
<li>当控制器接受一条命令后， 可独立于 CPU 完成制定操作； 命令完成时， 控制器产生中断通知系统； 通过读控制器中的信息， 获得结果和状态；</li>
<li>控制器与设备之间低级借口</li>
<li>任务： 串行位流转为字节块， 进行必要的错误修正</li>
</ul>
</li>
</ul>
<h2 id="I/O_端口地址">I/O 端口地址</h2><ul>
<li>I/O 端口地址： 接口电路中每个寄存器具有的、唯一的地址， 是个整数， 也叫 I/O 地址</li>
<li>所有I/O端口地址形成I/O端口空间（受到保护）</li>
<li>主要两种形式：<ul>
<li>内存映射编址（内存映射I/O）</li>
<li>I/O 独立编址（I/O 专用指令）</li>
</ul>
</li>
</ul>
<h3 id="I/O_独立编址">I/O 独立编址</h3><ul>
<li>端口地址空间与内存地址无关</li>
<li>优点：<ul>
<li>外设不占用内存地址空间</li>
<li>编程时易于区分内存操作和I/O操作</li>
</ul>
</li>
<li>缺点： I/O 端口操作的指令类型少， 操作不灵活 </li>
</ul>
<h3 id="内存映射编址">内存映射编址</h3><ul>
<li>分配各系统中所有端口的地址空间与内存的地址空间统一编址</li>
<li>把I/O端口看作一个存储单元， 对I/O的读写操作等同于对内存的操作</li>
<li>优点：<ul>
<li>凡是可对内存操作的指令都可对I/O端口操作</li>
<li>不需要专门的I/O指令</li>
<li>I/O 端口可有较大地址空间</li>
</ul>
</li>
<li>缺点： 占用内存地址空间</li>
<li>内存映射 I/O 可以直接用内存保护机制进行保护，不需要其他特殊机制， 但要避免把包含控制寄存器的那部分地址空间放入任何用户的虚拟地址空间之中</li>
<li>内存映射 I/O 的每一条指令也可以引用控制寄存器<ul>
<li>要注意对设备控制寄存器不能进行高速缓存， 否则无法探测到变化， 为避免这一情形， 硬件必须针对每个页面具备选择性禁用高速缓存的能力， 操作系统必须管理选择性高速缓存， 增加了复杂性</li>
</ul>
</li>
<li>内存映射 I/O ： 如果只存在一个地址空间， 那么所有的内存模块和所有的I/O设备都必须检查所有的内存引用， 以便了解谁做出响应<ul>
<li>如果单一总线， 那么让每个内存模块和I/O设备查看每个地址是简单易行的</li>
</ul>
</li>
</ul>
<h2 id="I/O_控制方式">I/O 控制方式</h2><ul>
<li>可编程I/O （轮询/查询）<ul>
<li>由 CPU 代表进程给 I/O 模块发 I/O 命令， 进程进入忙等待， 直到操作完成才继续执行</li>
</ul>
</li>
<li>中断驱动I/O    <ul>
<li>目的： 减少设备驱动程序不断得询问控制器状态寄存器的开销</li>
<li>实现： I/O 操作结束后， 由设备控制器主动通知设备驱动程序</li>
</ul>
</li>
<li><p>DMA</p>
</li>
<li><p>I/O 部件的演化</p>
<ol>
<li>CPU 直接控制外围设备</li>
<li>增加了控制器或I/O不见， CPU 使用非中断的可编程 I/O</li>
<li>与2相同， 但采用了中断方式。 CPU 无需花费等待执行一次 I/O 操作所需的时间， 因而提高了效率</li>
<li>I/O 部件通过 DMA 直接控制存储器， 可以在没有 CPU 参与的情况下， 从内存中移出或者往内存中移入一块数据， 仅仅在传送开始和结束时需要 CPU 干预</li>
<li>I/O 部件增强为一个单独的处理器， 有专门为 I/O 设计的指令集； CPU 指导 I/O 处理器执行内存中的一个 I/O 程序。 I/O 处理器在没有 CPU 干涉的情况下取指令并执行这些指令</li>
<li>I/O 部件有自己的局部存储器（其本身就是一台计算机）： 使用这种体系结构可以控制许多 I/O 设备， 并且使需要 CPU 参与程度降到最低（通常用于控制与交互终端的通信， I/O 处理器负责大多数控制终端的任务）</li>
</ol>
</li>
</ul>
<h2 id="I/O_软件设计">I/O 软件设计</h2><ul>
<li>分层的设计思想<ul>
<li>底层处理硬件相关特性</li>
<li>上层屏蔽细节 </li>
</ul>
</li>
<li>软件层次<ul>
<li>用户级 I/O</li>
<li>设备无关的 OS 软件<ul>
<li>驱动程序的统一接口</li>
<li>缓冲</li>
<li>错误报告</li>
<li>分配与释放设备</li>
<li>提供与设备无关的块大小  </li>
</ul>
</li>
<li>设备驱动</li>
<li>中断处理</li>
<li>硬件</li>
</ul>
</li>
<li>设备独立性<ul>
<li>用户编写的程序可以访问任意 I/O 设备， 无需实现制定设备</li>
<li>用户： 使用逻辑设备名</li>
<li>系统： 除了底层软件， 其他部分不依赖硬件</li>
</ul>
</li>
</ul>
<h2 id="缓冲技术">缓冲技术</h2><ul>
<li>提高 CPU 与 设备的并行性</li>
<li>减少中断请求次数</li>
<li>缓冲区分类<ul>
<li>硬缓冲： 由硬件寄存器实现（如： 设备中设置的缓冲区）</li>
<li>软缓冲： 在内存中开辟一个空间， 用作缓冲区</li>
</ul>
</li>
<li>缓冲区管理<ul>
<li>单缓冲</li>
<li>双缓冲</li>
<li>缓冲池（多缓冲， 循环缓冲）：统一管理多个缓冲区， 采用有界缓冲区的生产者/消费者模型对缓冲池中的缓冲区进行循环使用</li>
</ul>
</li>
<li><p>例子： 终端输入软件中的键盘驱动程序其任务之一： 收集字符</p>
<ul>
<li>常见两种字符缓冲方法：<ul>
<li>公共缓冲池（驱动程序中）</li>
<li>终端数据结构缓冲（终端绑定缓冲区）</li>
</ul>
</li>
<li>UNIX System V<ul>
<li>采用缓冲池技术， 可平滑和加快信息在内存和磁盘之间的传输</li>
<li>缓冲区结合提前读和延迟写技术对具有重复性及阵发性 I/O 进程、 提高 I/O 速度很有帮助</li>
<li>可以充分利用之前从磁盘读入、 虽已传入用户区但仍在缓冲区的数据（尽可能减少磁盘 I/O 的次数， 提高系统运行的速度）</li>
<li>缓冲池： 200个缓冲区（512字节或1024字节）</li>
<li>每个缓冲区由两部分组成： 缓冲控制块或缓冲首部 + 缓冲数据区</li>
<li>空闲缓冲区队列 （av链）： 队列头部为 bfreelist</li>
<li>设备缓冲队列（b链）： 链接所有分配给各类设备使用的缓冲区， 按照散列方式组织。<ul>
<li>双向链， 假设有64个队列， 每个队列首部有头标</li>
<li>根据块号计算队列号</li>
</ul>
</li>
<li>缓冲首部<ul>
<li>设备号和块号： 标志文件系统和数据所在的盘块号， 是缓冲区的唯一标志</li>
<li>状态项： 指明该缓冲区当前的状态： 忙/闲、 上锁/开锁、 是否延迟写、 数据有效性等</li>
<li>两组指针 av + b</li>
</ul>
</li>
<li>每个缓冲区同时在 av链 和 b 链<ul>
<li>开始： 在空闲 av 链（缓冲区未被使用）</li>
<li>开始 I/O 请求： 在设备I/O请求队列和设备b链</li>
<li>I/O 完成： 在空闲 av 链和设备 b 链</li>
</ul>
</li>
<li>进程想从盘块读数据时， 系统在 b 链中查找， 如果找到对应缓冲区， 则把该缓冲区标记为“忙”， 并从空闲 av 队列中取下， 然后完成从缓冲区到内存用户区的数据传送</li>
<li>如果设备 b 链中未找到时， 则从空闲 av 链队首摘取一个缓冲区， 插入设备 I/O 请求队列； 并从源设备 b 链中取下， 插入由读入信息盘块号确定的新的设备 b 链中</li>
<li>当数据从磁盘块读入到缓冲区后， 缓冲区从设备 I/O 请求队列取下； 当系统完成从缓冲区到内存用户去的数据传送后， 要把缓冲区释放， 插入 av 链队尾</li>
<li>当数据从磁盘块读入到缓冲区并传送到用户区后， 缓冲区保留在 b 链中，使用完后插入 av 尾部， 但数据仍然有效。 如果需要再次使用， 则从 av 链中摘下， 如果没有， 则缓冲区慢慢升到头部</li>
</ul>
</li>
</ul>
</li>
<li><p>设备管理有关的数据结构</p>
<ul>
<li>描述设备、 控制器等部件的表格</li>
<li>建立同类资源的队列： 把物理属性相同的设备连成队列（也称设备队列）</li>
<li>面向进程 I/O 请求的动态数据结构： 进程发出 I/O 请求时， 系统建立一张表格（I/O请求包）， 填入参数， 可以组成队列</li>
<li>建立 I/O 队列       </li>
</ul>
</li>
<li><p>独占设备的分配</p>
<ul>
<li>显式分配</li>
<li>静态分配： 运行前分配， 结束后回收 缺点： 效率低</li>
<li>动态分配： 可能产生死锁</li>
</ul>
</li>
<li><p>分时式共享设别的分配</p>
<ul>
<li>不同进程 I/O 请求排队</li>
</ul>
</li>
</ul>
<h2 id="设备驱动程序">设备驱动程序</h2><ul>
<li>驱动程序的任务是接收来自与设备无关的上层软件的抽象请求， 并执行这个请求</li>
<li>驱动程序的接口<ul>
<li>与操作系统的接口</li>
<li>与系统引导的接口： 初始化， 包括分配数据结构， 建立设备的请求队列</li>
<li>与设备的接口</li>
</ul>
</li>
</ul>
<h2 id="典型的实现方案：_I/O_进程">典型的实现方案： I/O 进程</h2><ul>
<li>I/O 进程： 专门处理系统中的 I/O 请求和 I/O 中断工作</li>
<li>I/O 请求的进入<ul>
<li>用户程序： 调用 send 将 I/O 请求发送给 I/O 进程； 调用 block 将自己阻塞， 直到 I/O 任务完成后被唤醒</li>
<li>系统： 利用 wakeup 唤醒 I/O 进程， 完成用户要求的操作</li>
</ul>
</li>
<li>I/O 中断的进入<ul>
<li>当 I/O 中断发生时， 内核中的中断处理程序发一条消息给 I/O 进程， 由 I/O 进程负责判断并处理中断</li>
</ul>
</li>
<li>是一个系统进程， 一般最高优先级， 一旦唤醒很快运行</li>
<li>I/O 进程开始运行后， 先关中断， 用 reveive 接收</li>
<li>有消息 （没有就关中断阻塞自己）<ul>
<li>I/O 请求： 准备通道程序（驱动）， 发出启动 I/O 指令， 继续判断有无消息</li>
<li>I/O 中断：<ul>
<li>正常结束： 唤醒对应进程</li>
<li>异常结束： 异常处理                                                                     </li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/deed.z" target="_blank" title="署名-相同方式共享">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/sa.png">
      
      <span>
        本作品采用知识共享 署名-相同方式共享 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


    

  </footer>
</article>







          <div class="main-footer">
  
    © 2021 未来机械研究所 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
